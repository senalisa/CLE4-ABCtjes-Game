{"dependencies":[{"name":"@pixi/settings","loc":{"line":8,"column":25}},{"name":"@pixi/core","loc":{"line":9,"column":37}},{"name":"@pixi/graphics","loc":{"line":10,"column":25}},{"name":"@pixi/ticker","loc":{"line":11,"column":40}},{"name":"@pixi/display","loc":{"line":12,"column":26}},{"name":"@pixi/text","loc":{"line":13,"column":45}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimeLimiter = exports.Prepare = exports.CountLimiter = exports.BasePrepare = undefined;\n\nvar _settings = require(\"@pixi/settings\");\n\nvar _core = require(\"@pixi/core\");\n\nvar _graphics = require(\"@pixi/graphics\");\n\nvar _ticker = require(\"@pixi/ticker\");\n\nvar _display = require(\"@pixi/display\");\n\nvar _text = require(\"@pixi/text\");\n\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\n/*!\n * @pixi/prepare - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/prepare is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n_settings.settings.UPLOADS_PER_FRAME = 4;\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/**\n * CountLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of items per frame.\n *\n * @memberof PIXI\n */\nvar CountLimiter = /** @class */function () {\n  /**\n   * @param maxItemsPerFrame - The maximum number of items that can be prepared each frame.\n   */\n  function CountLimiter(maxItemsPerFrame) {\n    this.maxItemsPerFrame = maxItemsPerFrame;\n    this.itemsLeft = 0;\n  }\n  /** Resets any counting properties to start fresh on a new frame. */\n  CountLimiter.prototype.beginFrame = function () {\n    this.itemsLeft = this.maxItemsPerFrame;\n  };\n  /**\n   * Checks to see if another item can be uploaded. This should only be called once per item.\n   *\n   * @return If the item is allowed to be uploaded.\n   */\n  CountLimiter.prototype.allowedToUpload = function () {\n    return this.itemsLeft-- > 0;\n  };\n  return CountLimiter;\n}();\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @return If a PIXI.Texture object was found.\n */\nfunction findMultipleBaseTextures(item, queue) {\n  var result = false;\n  // Objects with multiple textures\n  if (item && item._textures && item._textures.length) {\n    for (var i = 0; i < item._textures.length; i++) {\n      if (item._textures[i] instanceof _core.Texture) {\n        var baseTexture = item._textures[i].baseTexture;\n        if (queue.indexOf(baseTexture) === -1) {\n          queue.push(baseTexture);\n          result = true;\n        }\n      }\n    }\n  }\n  return result;\n}\n/**\n * Built-in hook to find BaseTextures from Texture.\n *\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @return If a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item, queue) {\n  if (item.baseTexture instanceof _core.BaseTexture) {\n    var texture = item.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @return If a PIXI.Texture object was found.\n */\nfunction findTexture(item, queue) {\n  if (item._texture && item._texture instanceof _core.Texture) {\n    var texture = item._texture.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param helper - Not used by this upload handler\n * @param item - Item to check\n * @return If item was uploaded.\n */\nfunction drawText(_helper, item) {\n  if (item instanceof _text.Text) {\n    // updating text will return early if it is not dirty\n    item.updateText(true);\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param helper - Not used by this upload handler\n * @param item - Item to check\n * @return If item was uploaded.\n */\nfunction calculateTextStyle(_helper, item) {\n  if (item instanceof _text.TextStyle) {\n    var font = item.toFontString();\n    _text.TextMetrics.measureFont(font);\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @return if a PIXI.Text object was found.\n */\nfunction findText(item, queue) {\n  if (item instanceof _text.Text) {\n    // push the text style to prepare it - this can be really expensive\n    if (queue.indexOf(item.style) === -1) {\n      queue.push(item.style);\n    }\n    // also push the text object so that we can render it (to canvas/texture) if needed\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n    // also push the Text's texture for upload to GPU\n    var texture = item._texture.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @return If a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue) {\n  if (item instanceof _text.TextStyle) {\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * The prepare manager provides functionality to upload content to the GPU.\n *\n * BasePrepare handles basic queuing functionality and is extended by\n * {@link PIXI.Prepare} and {@link PIXI.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = PIXI.Sprite.from('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @memberof PIXI\n */\nvar BasePrepare = /** @class */function () {\n  /**\n   * @param {PIXI.AbstractRenderer} renderer - A reference to the current renderer\n   */\n  function BasePrepare(renderer) {\n    var _this = this;\n    this.limiter = new CountLimiter(_settings.settings.UPLOADS_PER_FRAME);\n    this.renderer = renderer;\n    this.uploadHookHelper = null;\n    this.queue = [];\n    this.addHooks = [];\n    this.uploadHooks = [];\n    this.completes = [];\n    this.ticking = false;\n    this.delayedTick = function () {\n      // unlikely, but in case we were destroyed between tick() and delayedTick()\n      if (!_this.queue) {\n        return;\n      }\n      _this.prepareItems();\n    };\n    // hooks to find the correct texture\n    this.registerFindHook(findText);\n    this.registerFindHook(findTextStyle);\n    this.registerFindHook(findMultipleBaseTextures);\n    this.registerFindHook(findBaseTexture);\n    this.registerFindHook(findTexture);\n    // upload hooks\n    this.registerUploadHook(drawText);\n    this.registerUploadHook(calculateTextStyle);\n  }\n  /**\n   * Upload all the textures and graphics to the GPU.\n   *\n   * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n   *        Either the container or display object to search for items to upload, the items to upload themselves,\n   *        or the callback function, if items have been added using `prepare.add`.\n   * @param {Function} [done] - Optional callback when all queued uploads have completed\n   */\n  BasePrepare.prototype.upload = function (item, done) {\n    if (typeof item === 'function') {\n      done = item;\n      item = null;\n    }\n    // If a display object, search for items\n    // that we could upload\n    if (item) {\n      this.add(item);\n    }\n    // Get the items for upload from the display\n    if (this.queue.length) {\n      if (done) {\n        this.completes.push(done);\n      }\n      if (!this.ticking) {\n        this.ticking = true;\n        _ticker.Ticker.system.addOnce(this.tick, this, _ticker.UPDATE_PRIORITY.UTILITY);\n      }\n    } else if (done) {\n      done();\n    }\n  };\n  /**\n   * Handle tick update\n   *\n   * @private\n   */\n  BasePrepare.prototype.tick = function () {\n    setTimeout(this.delayedTick, 0);\n  };\n  /**\n   * Actually prepare items. This is handled outside of the tick because it will take a while\n   * and we do NOT want to block the current animation frame from rendering.\n   *\n   * @private\n   */\n  BasePrepare.prototype.prepareItems = function () {\n    this.limiter.beginFrame();\n    // Upload the graphics\n    while (this.queue.length && this.limiter.allowedToUpload()) {\n      var item = this.queue[0];\n      var uploaded = false;\n      if (item && !item._destroyed) {\n        for (var i = 0, len = this.uploadHooks.length; i < len; i++) {\n          if (this.uploadHooks[i](this.uploadHookHelper, item)) {\n            this.queue.shift();\n            uploaded = true;\n            break;\n          }\n        }\n      }\n      if (!uploaded) {\n        this.queue.shift();\n      }\n    }\n    // We're finished\n    if (!this.queue.length) {\n      this.ticking = false;\n      var completes = this.completes.slice(0);\n      this.completes.length = 0;\n      for (var i = 0, len = completes.length; i < len; i++) {\n        completes[i]();\n      }\n    } else {\n      // if we are not finished, on the next rAF do this again\n      _ticker.Ticker.system.addOnce(this.tick, this, _ticker.UPDATE_PRIORITY.UTILITY);\n    }\n  };\n  /**\n   * Adds hooks for finding items.\n   *\n   * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n   *          function must return `true` if it was able to add item to the queue.\n   * @return Instance of plugin for chaining.\n   */\n  BasePrepare.prototype.registerFindHook = function (addHook) {\n    if (addHook) {\n      this.addHooks.push(addHook);\n    }\n    return this;\n  };\n  /**\n   * Adds hooks for uploading items.\n   *\n   * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n   *          function must return `true` if it was able to handle upload of item.\n   * @return Instance of plugin for chaining.\n   */\n  BasePrepare.prototype.registerUploadHook = function (uploadHook) {\n    if (uploadHook) {\n      this.uploadHooks.push(uploadHook);\n    }\n    return this;\n  };\n  /**\n   * Manually add an item to the uploading queue.\n   *\n   * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n   *        add to the queue\n   * @return Instance of plugin for chaining.\n   */\n  BasePrepare.prototype.add = function (item) {\n    // Add additional hooks for finding elements on special\n    // types of objects that\n    for (var i = 0, len = this.addHooks.length; i < len; i++) {\n      if (this.addHooks[i](item, this.queue)) {\n        break;\n      }\n    }\n    // Get children recursively\n    if (item instanceof _display.Container) {\n      for (var i = item.children.length - 1; i >= 0; i--) {\n        this.add(item.children[i]);\n      }\n    }\n    return this;\n  };\n  /** Destroys the plugin, don't use after this. */\n  BasePrepare.prototype.destroy = function () {\n    if (this.ticking) {\n      _ticker.Ticker.system.remove(this.tick, this);\n    }\n    this.ticking = false;\n    this.addHooks = null;\n    this.uploadHooks = null;\n    this.renderer = null;\n    this.completes = null;\n    this.queue = null;\n    this.limiter = null;\n    this.uploadHookHelper = null;\n  };\n  return BasePrepare;\n}();\n\n/**\n * Built-in hook to upload PIXI.Texture objects to the GPU.\n *\n * @private\n * @param renderer - instance of the webgl renderer\n * @param item - Item to check\n * @return If item was uploaded.\n */\nfunction uploadBaseTextures(renderer, item) {\n  if (item instanceof _core.BaseTexture) {\n    // if the texture already has a GL texture, then the texture has been prepared or rendered\n    // before now. If the texture changed, then the changer should be calling texture.update() which\n    // reuploads the texture without need for preparing it again\n    if (!item._glTextures[renderer.CONTEXT_UID]) {\n      renderer.texture.bind(item);\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to upload PIXI.Graphics to the GPU.\n *\n * @private\n * @param renderer - instance of the webgl renderer\n * @param item - Item to check\n * @return If item was uploaded.\n */\nfunction uploadGraphics(renderer, item) {\n  if (!(item instanceof _graphics.Graphics)) {\n    return false;\n  }\n  var geometry = item.geometry;\n  // update dirty graphics to get batches\n  item.finishPoly();\n  geometry.updateBatches();\n  var batches = geometry.batches;\n  // upload all textures found in styles\n  for (var i = 0; i < batches.length; i++) {\n    var texture = batches[i].style.texture;\n    if (texture) {\n      uploadBaseTextures(renderer, texture.baseTexture);\n    }\n  }\n  // if its not batchable - update vao for particular shader\n  if (!geometry.batchable) {\n    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));\n  }\n  return true;\n}\n/**\n * Built-in hook to find graphics.\n *\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @return if a PIXI.Graphics object was found.\n */\nfunction findGraphics(item, queue) {\n  if (item instanceof _graphics.Graphics) {\n    queue.push(item);\n    return true;\n  }\n  return false;\n}\n/**\n * The prepare plugin provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @example\n * // Create a new application\n * const app = new PIXI.Application();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // create a display object\n * const rect = new PIXI.Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.plugins.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n *\n *\n * @memberof PIXI\n */\nvar Prepare = /** @class */function (_super) {\n  __extends(Prepare, _super);\n  /**\n   * @param {PIXI.Renderer} renderer - A reference to the current renderer\n   */\n  function Prepare(renderer) {\n    var _this = _super.call(this, renderer) || this;\n    _this.uploadHookHelper = _this.renderer;\n    // Add textures and graphics to upload\n    _this.registerFindHook(findGraphics);\n    _this.registerUploadHook(uploadBaseTextures);\n    _this.registerUploadHook(uploadGraphics);\n    return _this;\n  }\n  return Prepare;\n}(BasePrepare);\n\n/**\n * TimeLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of milliseconds per frame.\n *\n * @memberof PIXI\n */\nvar TimeLimiter = /** @class */function () {\n  /** @param maxMilliseconds - The maximum milliseconds that can be spent preparing items each frame. */\n  function TimeLimiter(maxMilliseconds) {\n    this.maxMilliseconds = maxMilliseconds;\n    this.frameStart = 0;\n  }\n  /** Resets any counting properties to start fresh on a new frame. */\n  TimeLimiter.prototype.beginFrame = function () {\n    this.frameStart = Date.now();\n  };\n  /**\n   * Checks to see if another item can be uploaded. This should only be called once per item.\n   *\n   * @return - If the item is allowed to be uploaded.\n   */\n  TimeLimiter.prototype.allowedToUpload = function () {\n    return Date.now() - this.frameStart < this.maxMilliseconds;\n  };\n  return TimeLimiter;\n}();\n\nexports.BasePrepare = BasePrepare;\nexports.CountLimiter = CountLimiter;\nexports.Prepare = Prepare;\nexports.TimeLimiter = TimeLimiter;\n//# sourceMappingURL=prepare.js.map"},"hash":"e5d2249e2e0e2af588990e9e64950306"}