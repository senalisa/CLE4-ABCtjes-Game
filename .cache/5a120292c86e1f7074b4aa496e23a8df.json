{"dependencies":[{"name":"@pixi/constants","loc":{"line":8,"column":28}},{"name":"@pixi/core","loc":{"line":9,"column":24}},{"name":"@pixi/display","loc":{"line":10,"column":34}},{"name":"@pixi/math","loc":{"line":11,"column":50}},{"name":"@pixi/settings","loc":{"line":12,"column":25}},{"name":"@pixi/utils","loc":{"line":13,"column":21}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Sprite = undefined;\n\nvar _constants = require(\"@pixi/constants\");\n\nvar _core = require(\"@pixi/core\");\n\nvar _display = require(\"@pixi/display\");\n\nvar _math = require(\"@pixi/math\");\n\nvar _settings = require(\"@pixi/settings\");\n\nvar _utils = require(\"@pixi/utils\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\n/*!\n * @pixi/sprite - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/sprite is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar tempPoint = new _math.Point();\nvar indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n*\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * let sprite = PIXI.Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link PIXI.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * PIXI.Loader.shared.add(\"assets/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"assets/spritesheet.json\"].spritesheet;\n *   let sprite = new PIXI.Sprite(sheet.textures[\"image.png\"]);\n *   ...\n * }\n * ```\n *\n * @memberof PIXI\n */\nvar Sprite = /** @class */function (_super) {\n  __extends(Sprite, _super);\n  /** @param texture - The texture for this sprite. */\n  function Sprite(texture) {\n    var _this = _super.call(this) || this;\n    _this._anchor = new _math.ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);\n    _this._texture = null;\n    _this._width = 0;\n    _this._height = 0;\n    _this._tint = null;\n    _this._tintRGB = null;\n    _this.tint = 0xFFFFFF;\n    _this.blendMode = _constants.BLEND_MODES.NORMAL;\n    _this._cachedTint = 0xFFFFFF;\n    _this.uvs = null;\n    // call texture setter\n    _this.texture = texture || _core.Texture.EMPTY;\n    _this.vertexData = new Float32Array(8);\n    _this.vertexTrimmedData = null;\n    _this._transformID = -1;\n    _this._textureID = -1;\n    _this._transformTrimmedID = -1;\n    _this._textureTrimmedID = -1;\n    // Batchable stuff..\n    // TODO could make this a mixin?\n    _this.indices = indices;\n    _this.pluginName = 'batch';\n    /**\n     * Used to fast check if a sprite is.. a sprite!\n     * @member {boolean}\n     */\n    _this.isSprite = true;\n    _this._roundPixels = _settings.settings.ROUND_PIXELS;\n    return _this;\n  }\n  /** When the texture is updated, this event will fire to update the scale and frame. */\n  Sprite.prototype._onTextureUpdate = function () {\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    this._cachedTint = 0xFFFFFF;\n    // so if _width is 0 then width was not set..\n    if (this._width) {\n      this.scale.x = (0, _utils.sign)(this.scale.x) * this._width / this._texture.orig.width;\n    }\n    if (this._height) {\n      this.scale.y = (0, _utils.sign)(this.scale.y) * this._height / this._texture.orig.height;\n    }\n  };\n  /** Called when the anchor position updates. */\n  Sprite.prototype._onAnchorUpdate = function () {\n    this._transformID = -1;\n    this._transformTrimmedID = -1;\n  };\n  /** Calculates worldTransform * vertices, store it in vertexData. */\n  Sprite.prototype.calculateVertices = function () {\n    var texture = this._texture;\n    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {\n      return;\n    }\n    // update texture UV here, because base texture can be changed without calling `_onTextureUpdate`\n    if (this._textureID !== texture._updateID) {\n      this.uvs = this._texture._uvs.uvsFloat32;\n    }\n    this._transformID = this.transform._worldID;\n    this._textureID = texture._updateID;\n    // set the vertex data\n    var wt = this.transform.worldTransform;\n    var a = wt.a;\n    var b = wt.b;\n    var c = wt.c;\n    var d = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var vertexData = this.vertexData;\n    var trim = texture.trim;\n    var orig = texture.orig;\n    var anchor = this._anchor;\n    var w0 = 0;\n    var w1 = 0;\n    var h0 = 0;\n    var h1 = 0;\n    if (trim) {\n      // if the sprite is trimmed and is not a tilingsprite then we need to add the extra\n      // space before transforming the sprite coords.\n      w1 = trim.x - anchor._x * orig.width;\n      w0 = w1 + trim.width;\n      h1 = trim.y - anchor._y * orig.height;\n      h0 = h1 + trim.height;\n    } else {\n      w1 = -anchor._x * orig.width;\n      w0 = w1 + orig.width;\n      h1 = -anchor._y * orig.height;\n      h0 = h1 + orig.height;\n    }\n    // xy\n    vertexData[0] = a * w1 + c * h1 + tx;\n    vertexData[1] = d * h1 + b * w1 + ty;\n    // xy\n    vertexData[2] = a * w0 + c * h1 + tx;\n    vertexData[3] = d * h1 + b * w0 + ty;\n    // xy\n    vertexData[4] = a * w0 + c * h0 + tx;\n    vertexData[5] = d * h0 + b * w0 + ty;\n    // xy\n    vertexData[6] = a * w1 + c * h0 + tx;\n    vertexData[7] = d * h0 + b * w1 + ty;\n    if (this._roundPixels) {\n      var resolution = _settings.settings.RESOLUTION;\n      for (var i = 0; i < vertexData.length; ++i) {\n        vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);\n      }\n    }\n  };\n  /**\n   * Calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData.\n   *\n   * This is used to ensure that the true width and height of a trimmed texture is respected.\n   */\n  Sprite.prototype.calculateTrimmedVertices = function () {\n    if (!this.vertexTrimmedData) {\n      this.vertexTrimmedData = new Float32Array(8);\n    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {\n      return;\n    }\n    this._transformTrimmedID = this.transform._worldID;\n    this._textureTrimmedID = this._texture._updateID;\n    // lets do some special trim code!\n    var texture = this._texture;\n    var vertexData = this.vertexTrimmedData;\n    var orig = texture.orig;\n    var anchor = this._anchor;\n    // lets calculate the new untrimmed bounds..\n    var wt = this.transform.worldTransform;\n    var a = wt.a;\n    var b = wt.b;\n    var c = wt.c;\n    var d = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var w1 = -anchor._x * orig.width;\n    var w0 = w1 + orig.width;\n    var h1 = -anchor._y * orig.height;\n    var h0 = h1 + orig.height;\n    // xy\n    vertexData[0] = a * w1 + c * h1 + tx;\n    vertexData[1] = d * h1 + b * w1 + ty;\n    // xy\n    vertexData[2] = a * w0 + c * h1 + tx;\n    vertexData[3] = d * h1 + b * w0 + ty;\n    // xy\n    vertexData[4] = a * w0 + c * h0 + tx;\n    vertexData[5] = d * h0 + b * w0 + ty;\n    // xy\n    vertexData[6] = a * w1 + c * h0 + tx;\n    vertexData[7] = d * h0 + b * w1 + ty;\n  };\n  /**\n   *\n   * Renders the object using the WebGL renderer\n   *\n   * @param renderer - The webgl renderer to use.\n   */\n  Sprite.prototype._render = function (renderer) {\n    this.calculateVertices();\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  };\n  /** Updates the bounds of the sprite. */\n  Sprite.prototype._calculateBounds = function () {\n    var trim = this._texture.trim;\n    var orig = this._texture.orig;\n    // First lets check to see if the current texture has a trim..\n    if (!trim || trim.width === orig.width && trim.height === orig.height) {\n      // no trim! lets use the usual calculations..\n      this.calculateVertices();\n      this._bounds.addQuad(this.vertexData);\n    } else {\n      // lets calculate a special trimmed bounds...\n      this.calculateTrimmedVertices();\n      this._bounds.addQuad(this.vertexTrimmedData);\n    }\n  };\n  /**\n   * Gets the local bounds of the sprite object.\n   *\n   * @param rect - Optional output rectangle.\n   * @return The bounds.\n   */\n  Sprite.prototype.getLocalBounds = function (rect) {\n    // we can do a fast local bounds if the sprite has no children!\n    if (this.children.length === 0) {\n      if (!this._localBounds) {\n        this._localBounds = new _display.Bounds();\n      }\n      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;\n      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;\n      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);\n      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new _math.Rectangle();\n        }\n        rect = this._localBoundsRect;\n      }\n      return this._localBounds.getRectangle(rect);\n    }\n    return _super.prototype.getLocalBounds.call(this, rect);\n  };\n  /**\n   * Tests if a point is inside this sprite\n   *\n   * @param point - the point to test\n   * @return The result of the test\n   */\n  Sprite.prototype.containsPoint = function (point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    var width = this._texture.orig.width;\n    var height = this._texture.orig.height;\n    var x1 = -width * this.anchor.x;\n    var y1 = 0;\n    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\n   * Destroys this sprite and optionally its texture and children.\n   *\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param [options.children=false] - if set to true, all the children will have their destroy\n   *      method called as well. 'options' will be passed on to those calls.\n   * @param [options.texture=false] - Should it destroy the current texture of the sprite as well\n   * @param [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n   */\n  Sprite.prototype.destroy = function (options) {\n    _super.prototype.destroy.call(this, options);\n    this._texture.off('update', this._onTextureUpdate, this);\n    this._anchor = null;\n    var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;\n    if (destroyTexture) {\n      var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;\n      this._texture.destroy(!!destroyBaseTexture);\n    }\n    this._texture = null;\n  };\n  // some helper functions..\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   *\n   * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n   * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.\n   * @return The newly created sprite\n   */\n  Sprite.from = function (source, options) {\n    var texture = source instanceof _core.Texture ? source : _core.Texture.from(source, options);\n    return new Sprite(texture);\n  };\n  Object.defineProperty(Sprite.prototype, \"roundPixels\", {\n    get: function () {\n      return this._roundPixels;\n    },\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     *\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     *\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.\n     *\n     * @default false\n     */\n    set: function (value) {\n      if (this._roundPixels !== value) {\n        this._transformID = -1;\n      }\n      this._roundPixels = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"width\", {\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get: function () {\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function (value) {\n      var s = (0, _utils.sign)(this.scale.x) || 1;\n      this.scale.x = s * value / this._texture.orig.width;\n      this._width = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"height\", {\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get: function () {\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function (value) {\n      var s = (0, _utils.sign)(this.scale.y) || 1;\n      this.scale.y = s * value / this._texture.orig.height;\n      this._height = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"anchor\", {\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     *\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get: function () {\n      return this._anchor;\n    },\n    set: function (value) {\n      this._anchor.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"tint\", {\n    /**\n     * The tint applied to the sprite. This is a hex value.\n     *\n     * A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @default 0xFFFFFF\n     */\n    get: function () {\n      return this._tint;\n    },\n    set: function (value) {\n      this._tint = value;\n      this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"texture\", {\n    /** The texture that the sprite is using. */\n    get: function () {\n      return this._texture;\n    },\n    set: function (value) {\n      if (this._texture === value) {\n        return;\n      }\n      if (this._texture) {\n        this._texture.off('update', this._onTextureUpdate, this);\n      }\n      this._texture = value || _core.Texture.EMPTY;\n      this._cachedTint = 0xFFFFFF;\n      this._textureID = -1;\n      this._textureTrimmedID = -1;\n      if (value) {\n        // wait for the texture to load\n        if (value.baseTexture.valid) {\n          this._onTextureUpdate();\n        } else {\n          value.once('update', this._onTextureUpdate, this);\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Sprite;\n}(_display.Container);\n\nexports.Sprite = Sprite;\n//# sourceMappingURL=sprite.js.map"},"hash":"29d9edeecb552f7443a4db9a887bb46b"}