{"dependencies":[{"name":"@pixi/core","loc":{"line":8,"column":115}},{"name":"@pixi/math","loc":{"line":9,"column":99}},{"name":"@pixi/utils","loc":{"line":10,"column":49}},{"name":"@pixi/constants","loc":{"line":11,"column":52}},{"name":"@pixi/display","loc":{"line":12,"column":34}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.graphicsUtils = exports.LineStyle = exports.LINE_JOIN = exports.LINE_CAP = exports.GraphicsGeometry = exports.GraphicsData = exports.Graphics = exports.GRAPHICS_CURVES = exports.FillStyle = undefined;\n\nvar _core = require(\"@pixi/core\");\n\nvar _math = require(\"@pixi/math\");\n\nvar _utils = require(\"@pixi/utils\");\n\nvar _constants = require(\"@pixi/constants\");\n\nvar _display = require(\"@pixi/display\");\n\n/**\n * Supported line joints in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\n *\n * @name LINE_JOIN\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} MITER - 'miter': make a sharp corner where outer part of lines meet\n * @property {string} BEVEL - 'bevel': add a square butt at each end of line segment and fill the triangle at turn\n * @property {string} ROUND - 'round': add an arc at the joint\n */\nvar LINE_JOIN; /*!\n                * @pixi/graphics - v6.3.2\n                * Compiled Wed, 04 May 2022 17:49:13 UTC\n                *\n                * @pixi/graphics is licensed under the MIT License.\n                * http://www.opensource.org/licenses/mit-license\n                */\n\n(function (LINE_JOIN) {\n  LINE_JOIN[\"MITER\"] = \"miter\";\n  LINE_JOIN[\"BEVEL\"] = \"bevel\";\n  LINE_JOIN[\"ROUND\"] = \"round\";\n})(LINE_JOIN || (exports.LINE_JOIN = LINE_JOIN = {}));\n/**\n * Support line caps in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n *\n * @name LINE_CAP\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} BUTT - 'butt': don't add any cap at line ends (leaves orthogonal edges)\n * @property {string} ROUND - 'round': add semicircle at ends\n * @property {string} SQUARE - 'square': add square at end (like `BUTT` except more length at end)\n */\nvar LINE_CAP;\n(function (LINE_CAP) {\n  LINE_CAP[\"BUTT\"] = \"butt\";\n  LINE_CAP[\"ROUND\"] = \"round\";\n  LINE_CAP[\"SQUARE\"] = \"square\";\n})(LINE_CAP || (exports.LINE_CAP = LINE_CAP = {}));\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} adaptive=true - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nvar GRAPHICS_CURVES = {\n  adaptive: true,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 0.0001,\n  _segmentsCount: function (length, defaultSegments) {\n    if (defaultSegments === void 0) {\n      defaultSegments = 20;\n    }\n    if (!this.adaptive || !length || isNaN(length)) {\n      return defaultSegments;\n    }\n    var result = Math.ceil(length / this.maxLength);\n    if (result < this.minSegments) {\n      result = this.minSegments;\n    } else if (result > this.maxSegments) {\n      result = this.maxSegments;\n    }\n    return result;\n  }\n};\n\n/**\n * Fill style object for Graphics.\n *\n * @memberof PIXI\n */\nvar FillStyle = /** @class */function () {\n  function FillStyle() {\n    /**\n     * The hex color value used when coloring the Graphics object.\n     *\n     * @default 0xFFFFFF\n     */\n    this.color = 0xFFFFFF;\n    /** The alpha value used when filling the Graphics object. */\n    this.alpha = 1.0;\n    /**\n     * The texture to be used for the fill.\n     *\n     * @default 0\n     */\n    this.texture = _core.Texture.WHITE;\n    /**\n     * The transform applied to the texture.\n     *\n     * @default null\n     */\n    this.matrix = null;\n    /** If the current fill is visible. */\n    this.visible = false;\n    this.reset();\n  }\n  /** Clones the object */\n  FillStyle.prototype.clone = function () {\n    var obj = new FillStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    return obj;\n  };\n  /** Reset */\n  FillStyle.prototype.reset = function () {\n    this.color = 0xFFFFFF;\n    this.alpha = 1;\n    this.texture = _core.Texture.WHITE;\n    this.matrix = null;\n    this.visible = false;\n  };\n  /** Destroy and don't use after this. */\n  FillStyle.prototype.destroy = function () {\n    this.texture = null;\n    this.matrix = null;\n  };\n  return FillStyle;\n}();\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nfunction fixOrientation(points, hole) {\n  var _a, _b;\n  if (hole === void 0) {\n    hole = false;\n  }\n  var m = points.length;\n  if (m < 6) {\n    return;\n  }\n  var area = 0;\n  for (var i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    var x2 = points[i];\n    var y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (!hole && area > 0 || hole && area <= 0) {\n    var n = m / 2;\n    for (var i = n + n % 2; i < m; i += 2) {\n      var i1 = m - i - 2;\n      var i2 = m - i - 1;\n      var i3 = i;\n      var i4 = i + 1;\n      _a = [points[i3], points[i1]], points[i1] = _a[0], points[i3] = _a[1];\n      _b = [points[i4], points[i2]], points[i2] = _b[0], points[i4] = _b[1];\n    }\n  }\n}\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildPoly = {\n  build: function (graphicsData) {\n    graphicsData.points = graphicsData.shape.points.slice();\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var holes = graphicsData.holes;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    if (points.length >= 6) {\n      fixOrientation(points, false);\n      var holeArray = [];\n      // Process holes..\n      for (var i = 0; i < holes.length; i++) {\n        var hole = holes[i];\n        fixOrientation(hole.points, true);\n        holeArray.push(points.length / 2);\n        points = points.concat(hole.points);\n      }\n      // sort color\n      var triangles = (0, _utils.earcut)(points, holeArray, 2);\n      if (!triangles) {\n        return;\n      }\n      var vertPos = verts.length / 2;\n      for (var i = 0; i < triangles.length; i += 3) {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i + 1] + vertPos);\n        indices.push(triangles[i + 2] + vertPos);\n      }\n      for (var i = 0; i < points.length; i++) {\n        verts.push(points[i]);\n      }\n    }\n  }\n};\n\n// for type only\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildCircle = {\n  build: function (graphicsData) {\n    // need to convert points to a nice regular data\n    var points = graphicsData.points;\n    var x;\n    var y;\n    var dx;\n    var dy;\n    var rx;\n    var ry;\n    if (graphicsData.type === _math.SHAPES.CIRC) {\n      var circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === _math.SHAPES.ELIP) {\n      var ellipse = graphicsData.shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      var roundedRect = graphicsData.shape;\n      var halfWidth = roundedRect.width / 2;\n      var halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n    var n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    var m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m;\n    if (m === 0) {\n      return;\n    }\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return;\n    }\n    var j1 = 0;\n    var j2 = n * 4 + (dx ? 2 : 0) + 2;\n    var j3 = j2;\n    var j4 = m;\n    {\n      var x0 = dx + rx;\n      var y0 = dy;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      if (dy) {\n        var y2 = y - y0;\n        points[j3++] = x2;\n        points[j3++] = y2;\n        points[--j4] = y2;\n        points[--j4] = x1;\n      }\n    }\n    for (var i = 1; i < n; i++) {\n      var a = Math.PI / 2 * (i / n);\n      var x0 = dx + Math.cos(a) * rx;\n      var y0 = dy + Math.sin(a) * ry;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      var y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      points[j3++] = x2;\n      points[j3++] = y2;\n      points[--j4] = y2;\n      points[--j4] = x1;\n    }\n    {\n      var x0 = dx;\n      var y0 = dy + ry;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      var y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x1;\n      if (dx) {\n        points[j1++] = x2;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x2;\n      }\n    }\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    var vertPos = verts.length / 2;\n    var center = vertPos;\n    var x;\n    var y;\n    if (graphicsData.type !== _math.SHAPES.RREC) {\n      var circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n    } else {\n      var roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2;\n      y = roundedRect.y + roundedRect.height / 2;\n    }\n    var matrix = graphicsData.matrix;\n    // Push center (special point)\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    vertPos++;\n    verts.push(points[0], points[1]);\n    for (var i = 2; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]);\n      // add some uvs\n      indices.push(vertPos++, center, vertPos);\n    }\n    indices.push(center + 1, center, vertPos);\n  }\n};\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildRectangle = {\n  build: function (graphicsData) {\n    // --- //\n    // need to convert points to a nice regular data\n    //\n    var rectData = graphicsData.shape;\n    var x = rectData.x;\n    var y = rectData.y;\n    var width = rectData.width;\n    var height = rectData.height;\n    var points = graphicsData.points;\n    points.length = 0;\n    points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var vertPos = verts.length / 2;\n    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);\n    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);\n  }\n};\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1, n2, perc) {\n  var diff = n2 - n1;\n  return n1 + diff * perc;\n}\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {\n  if (out === void 0) {\n    out = [];\n  }\n  var n = 20;\n  var points = out;\n  var xa = 0;\n  var ya = 0;\n  var xb = 0;\n  var yb = 0;\n  var x = 0;\n  var y = 0;\n  for (var i = 0, j = 0; i <= n; ++i) {\n    j = i / n;\n    // The Green Line\n    xa = getPt(fromX, cpX, j);\n    ya = getPt(fromY, cpY, j);\n    xb = getPt(cpX, toX, j);\n    yb = getPt(cpY, toY, j);\n    // The Black Dot\n    x = getPt(xa, xb, j);\n    y = getPt(ya, yb, j);\n    // Handle case when first curve points overlaps and earcut fails to triangulate\n    if (i === 0 && points[points.length - 2] === x && points[points.length - 1] === y) {\n      continue;\n    }\n    points.push(x, y);\n  }\n  return points;\n}\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildRoundedRectangle = {\n  build: function (graphicsData) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.build(graphicsData);\n      return;\n    }\n    var rrectData = graphicsData.shape;\n    var points = graphicsData.points;\n    var x = rrectData.x;\n    var y = rrectData.y;\n    var width = rrectData.width;\n    var height = rrectData.height;\n    // Don't allow negative radius or greater than half the smallest width\n    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\n    points.length = 0;\n    // No radius, do a simple rectangle\n    if (!radius) {\n      points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n    } else {\n      quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);\n      quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);\n      quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);\n      quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);\n    }\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.triangulate(graphicsData, graphicsGeometry);\n      return;\n    }\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    var vecPos = verts.length / 2;\n    var triangles = (0, _utils.earcut)(points, null, 2);\n    for (var i = 0, j = triangles.length; i < j; i += 3) {\n      indices.push(triangles[i] + vecPos);\n      //     indices.push(triangles[i] + vecPos);\n      indices.push(triangles[i + 1] + vecPos);\n      //   indices.push(triangles[i + 2] + vecPos);\n      indices.push(triangles[i + 2] + vecPos);\n    }\n    for (var i = 0, j = points.length; i < j; i++) {\n      verts.push(points[i], points[++i]);\n    }\n  }\n};\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {Array<number>} verts - vertex buffer\n * @returns {}\n */\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, /* rotation for square (true at left end, false at right end) */verts) {\n  var ix = x - nx * innerWeight;\n  var iy = y - ny * innerWeight;\n  var ox = x + nx * outerWeight;\n  var oy = y + ny * outerWeight;\n  /* Rotate nx,ny for extension vector */\n  var exx;\n  var eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  /* [i|0]x,y extended at cap */\n  var eix = ix + exx;\n  var eiy = iy + eyy;\n  var eox = ox + exx;\n  var eoy = oy + eyy;\n  /* Square itself must be inserted clockwise*/\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  var cx2p0x = sx - cx;\n  var cy2p0y = sy - cy;\n  var angle0 = Math.atan2(cx2p0x, cy2p0y);\n  var angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  var startAngle = angle0;\n  var angleDiff = angle1 - angle0;\n  var absAngleDiff = Math.abs(angleDiff);\n  /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n  {\n      const r1x = cx - nxtPx;\n      const r1y = cy - nxtPy;\n       if (r1x === 0)\n      {\n          if (r1y > 0)\n          {\n              angleDiff = -angleDiff;\n          }\n      }\n      else if (r1x >= -GRAPHICS_CURVES.epsilon)\n      {\n          angleDiff = -angleDiff;\n      }\n  }*/\n  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  var angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points.slice();\n  var eps = graphicsGeometry.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  // if the line width is an odd number add 0.5 to align to a whole pixel\n  // commenting this out fixes #711 and #1620\n  // if (graphicsData.lineWidth%2)\n  // {\n  //     for (i = 0; i < points.length; i++)\n  //     {\n  //         points[i] += 0.5;\n  //     }\n  // }\n  var style = graphicsData.lineStyle;\n  // get first and last point.. figure out the middle!\n  var firstPoint = new _math.Point(points[0], points[1]);\n  var lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);\n  var closedShape = shape.type !== _math.SHAPES.POLY || shape.closeStroke;\n  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  // if the first point is the last point - gonna have issues :)\n  if (closedShape) {\n    // need to clone as we are going to slightly modify the shape..\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  var verts = graphicsGeometry.points;\n  var length = points.length / 2;\n  var indexCount = points.length;\n  var indexStart = verts.length / 2;\n  // Max. inner and outer width\n  var width = style.width / 2;\n  var widthSquared = width * width;\n  var miterLimitSquared = style.miterLimit * style.miterLimit;\n  /* Line segments of interest where (x1,y1) forms the corner. */\n  var x0 = points[0];\n  var y0 = points[1];\n  var x1 = points[2];\n  var y1 = points[3];\n  var x2 = 0;\n  var y2 = 0;\n  /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n  var perpx = -(y0 - y1);\n  var perpy = x0 - x1;\n  var perp1x = 0;\n  var perp1y = 0;\n  var dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  var ratio = style.alignment; // 0.5;\n  var innerWeight = (1 - ratio) * 2;\n  var outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n  }\n  // Push first point (below & above vertices)\n  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);\n  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n  for (var i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n    var dx0 = x1 - x0;\n    var dy0 = y0 - y1;\n    var dx1 = x1 - x2;\n    var dy1 = y2 - y1;\n    /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n    var cross = dy0 * dx1 - dy1 * dx0;\n    var clockwise = cross < 0;\n    /* Going nearly straight? */\n    if (Math.abs(cross) < 0.1) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      continue;\n    }\n    /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);\n    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    var px = (dx0 * c2 - dx1 * c1) / cross;\n    var py = (dy1 * c1 - dy0 * c2) / cross;\n    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    /* Inner miter point */\n    var imx = x1 + (px - x1) * innerWeight;\n    var imy = y1 + (py - y1) * innerWeight;\n    /* Outer miter point */\n    var omx = x1 - (px - x1) * outerWeight;\n    var omy = y1 - (py - y1) * outerWeight;\n    /* Is the inside miter point too far away, creating a spike? */\n    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    var insideWeight = clockwise ? innerWeight : outerWeight;\n    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    var insideMiterOk = pdist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {\n        if (clockwise) /* rotating at inner angle */{\n            verts.push(imx, imy); // inner miter point\n            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight); // first segment's outer vertex\n            verts.push(imx, imy); // inner miter point\n            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight); // second segment's outer vertex\n          } else /* rotating at outer angle */{\n            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight); // first segment's inner vertex\n            verts.push(omx, omy); // outer miter point\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight); // second segment's outer vertex\n            verts.push(omx, omy); // outer miter point\n          }\n        indexCount += 2;\n      } else if (style.join === LINE_JOIN.ROUND) {\n        if (clockwise) /* arc is outside */{\n            verts.push(imx, imy);\n            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n            verts.push(imx, imy);\n            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n          } else /* arc is inside */{\n            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n            verts.push(omx, omy);\n            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n            verts.push(omx, omy);\n          }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else // inside miter is NOT ok\n      {\n        verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight); // first segment's inner vertex\n        verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight); // first segment's outer vertex\n        if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) ;else if (style.join === LINE_JOIN.ROUND) {\n          if (clockwise) /* arc is outside */{\n              indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n            } else /* arc is inside */{\n              indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n            }\n        } else {\n          if (clockwise) {\n            verts.push(omx, omy); // inner miter point\n            verts.push(omx, omy); // inner miter point\n          } else {\n            verts.push(imx, imy); // outer miter point\n            verts.push(imx, imy); // outer miter point\n          }\n          indexCount += 2;\n        }\n        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight); // second segment's inner vertex\n        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight); // second segment's outer vertex\n        indexCount += 2;\n      }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpx = -(y0 - y1);\n  perpy = x0 - x1;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n  }\n  var indices = graphicsGeometry.indices;\n  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n  // indices.push(indexStart);\n  for (var i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    /* Skip zero area triangles */\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  var i = 0;\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points;\n  var closedShape = shape.type !== _math.SHAPES.POLY || shape.closeStroke;\n  if (points.length === 0) {\n    return;\n  }\n  var verts = graphicsGeometry.points;\n  var indices = graphicsGeometry.indices;\n  var length = points.length / 2;\n  var startIndex = verts.length / 2;\n  var currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n  for (i = 1; i < length; i++) {\n    verts.push(points[i * 2], points[i * 2 + 1]);\n    indices.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n  if (closedShape) {\n    indices.push(currentIndex, startIndex);\n  }\n}\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\n\n/**\n * Utilities for arc curves.\n *\n * @private\n */\nvar ArcUtils = /** @class */function () {\n  function ArcUtils() {}\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   *\n   * @private\n   * @param x1 - The x-coordinate of the beginning of the arc\n   * @param y1 - The y-coordinate of the beginning of the arc\n   * @param x2 - The x-coordinate of the end of the arc\n   * @param y2 - The y-coordinate of the end of the arc\n   * @param radius - The radius of the arc\n   * @return - If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n   */\n  ArcUtils.curveTo = function (x1, y1, x2, y2, radius, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var a1 = fromY - y1;\n    var b1 = fromX - x1;\n    var a2 = y2 - y1;\n    var b2 = x2 - x1;\n    var mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1.0e-8 || radius === 0) {\n      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n        points.push(x1, y1);\n      }\n      return null;\n    }\n    var dd = a1 * a1 + b1 * b1;\n    var cc = a2 * a2 + b2 * b2;\n    var tt = a1 * a2 + b1 * b2;\n    var k1 = radius * Math.sqrt(dd) / mm;\n    var k2 = radius * Math.sqrt(cc) / mm;\n    var j1 = k1 * tt / dd;\n    var j2 = k2 * tt / cc;\n    var cx = k1 * b2 + k2 * b1;\n    var cy = k1 * a2 + k2 * a1;\n    var px = b1 * (k2 + j1);\n    var py = a1 * (k2 + j1);\n    var qx = b2 * (k1 + j2);\n    var qy = a2 * (k1 + j2);\n    var startAngle = Math.atan2(py - cy, px - cx);\n    var endAngle = Math.atan2(qy - cy, qx - cx);\n    return {\n      cx: cx + x1,\n      cy: cy + y1,\n      radius: radius,\n      startAngle: startAngle,\n      endAngle: endAngle,\n      anticlockwise: b1 * a2 > b2 * a1\n    };\n  };\n  /* eslint-disable max-len */\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   *\n   * @private\n   * @param startX - Start x location of arc\n   * @param startY - Start y location of arc\n   * @param cx - The x-coordinate of the center of the circle\n   * @param cy - The y-coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param endAngle - The ending angle, in radians\n   * @param anticlockwise - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @param points - Collection of points to add to\n   */\n  ArcUtils.arc = function (_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {\n    var sweep = endAngle - startAngle;\n    var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / _math.PI_2) * 40);\n    var theta = sweep / (n * 2);\n    var theta2 = theta * 2;\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n    var segMinus = n - 1;\n    var remainder = segMinus % 1 / segMinus;\n    for (var i = 0; i <= segMinus; ++i) {\n      var real = i + remainder * i;\n      var angle = theta + startAngle + theta2 * real;\n      var c = Math.cos(angle);\n      var s = -Math.sin(angle);\n      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n    }\n  };\n  return ArcUtils;\n}();\n\n/**\n * Utilities for bezier curves\n *\n * @private\n */\nvar BezierUtils = /** @class */function () {\n  function BezierUtils() {}\n  /**\n   * Calculate length of bezier curve.\n   * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n   * Therefore numerical solution is used.\n   *\n   * @private\n   * @param fromX - Starting point x\n   * @param fromY - Starting point y\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @return - Length of bezier curve\n   */\n  BezierUtils.curveLength = function (fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    var n = 10;\n    var result = 0.0;\n    var t = 0.0;\n    var t2 = 0.0;\n    var t3 = 0.0;\n    var nt = 0.0;\n    var nt2 = 0.0;\n    var nt3 = 0.0;\n    var x = 0.0;\n    var y = 0.0;\n    var dx = 0.0;\n    var dy = 0.0;\n    var prevX = fromX;\n    var prevY = fromY;\n    for (var i = 1; i <= n; ++i) {\n      t = i / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1.0 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x = nt3 * fromX + 3.0 * nt2 * t * cpX + 3.0 * nt * t2 * cpX2 + t3 * toX;\n      y = nt3 * fromY + 3.0 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x;\n      dy = prevY - y;\n      prevX = x;\n      prevY = y;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n    return result;\n  };\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * Ignored from docs since it is not directly exposed.\n   *\n   * @ignore\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @param points - Path array to push points into\n   */\n  BezierUtils.curveTo = function (cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    points.length -= 2;\n    var n = GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n    var dt = 0;\n    var dt2 = 0;\n    var dt3 = 0;\n    var t2 = 0;\n    var t3 = 0;\n    points.push(fromX, fromY);\n    for (var i = 1, j = 0; i <= n; ++i) {\n      j = i / n;\n      dt = 1 - j;\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n      t2 = j * j;\n      t3 = t2 * j;\n      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n  };\n  return BezierUtils;\n}();\n\n/**\n * Utilities for quadratic curves.\n *\n * @private\n */\nvar QuadraticUtils = /** @class */function () {\n  function QuadraticUtils() {}\n  /**\n   * Calculate length of quadratic curve\n   * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n   * for the detailed explanation of math behind this.\n   *\n   * @private\n   * @param fromX - x-coordinate of curve start point\n   * @param fromY - y-coordinate of curve start point\n   * @param cpX - x-coordinate of curve control point\n   * @param cpY - y-coordinate of curve control point\n   * @param toX - x-coordinate of curve end point\n   * @param toY - y-coordinate of curve end point\n   * @return - Length of quadratic curve\n   */\n  QuadraticUtils.curveLength = function (fromX, fromY, cpX, cpY, toX, toY) {\n    var ax = fromX - 2.0 * cpX + toX;\n    var ay = fromY - 2.0 * cpY + toY;\n    var bx = 2.0 * cpX - 2.0 * fromX;\n    var by = 2.0 * cpY - 2.0 * fromY;\n    var a = 4.0 * (ax * ax + ay * ay);\n    var b = 4.0 * (ax * bx + ay * by);\n    var c = bx * bx + by * by;\n    var s = 2.0 * Math.sqrt(a + b + c);\n    var a2 = Math.sqrt(a);\n    var a32 = 2.0 * a * a2;\n    var c2 = 2.0 * Math.sqrt(c);\n    var ba = b / a2;\n    return (a32 * s + a2 * b * (s - c2) + (4.0 * c * a - b * b) * Math.log((2.0 * a2 + ba + s) / (ba + c2))) / (4.0 * a32);\n  };\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   *\n   * @private\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @param points - Points to add segments to.\n   */\n  QuadraticUtils.curveTo = function (cpX, cpY, toX, toY, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));\n    var xa = 0;\n    var ya = 0;\n    for (var i = 1; i <= n; ++i) {\n      var j = i / n;\n      xa = fromX + (cpX - fromX) * j;\n      ya = fromY + (cpY - fromY) * j;\n      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n    }\n  };\n  return QuadraticUtils;\n}();\n\n/**\n * A structure to hold interim batch objects for Graphics.\n *\n * @memberof PIXI.graphicsUtils\n */\nvar BatchPart = /** @class */function () {\n  function BatchPart() {\n    this.reset();\n  }\n  /** Begin batch part. */\n  BatchPart.prototype.begin = function (style, startIndex, attribStart) {\n    this.reset();\n    this.style = style;\n    this.start = startIndex;\n    this.attribStart = attribStart;\n  };\n  /** End batch part. */\n  BatchPart.prototype.end = function (endIndex, endAttrib) {\n    this.attribSize = endAttrib - this.attribStart;\n    this.size = endIndex - this.start;\n  };\n  BatchPart.prototype.reset = function () {\n    this.style = null;\n    this.size = 0;\n    this.start = 0;\n    this.attribStart = 0;\n    this.attribSize = 0;\n  };\n  return BatchPart;\n}();\n\n/**\n * Generalized convenience utilities for Graphics.\n *\n * @namespace graphicsUtils\n * @memberof PIXI\n */\nvar _a;\n/**\n * Map of fill commands for each shape type.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Object} FILL_COMMANDS\n */\nvar FILL_COMMANDS = (_a = {}, _a[_math.SHAPES.POLY] = buildPoly, _a[_math.SHAPES.CIRC] = buildCircle, _a[_math.SHAPES.ELIP] = buildCircle, _a[_math.SHAPES.RECT] = buildRectangle, _a[_math.SHAPES.RREC] = buildRoundedRectangle, _a);\n/**\n * Batch pool, stores unused batches for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.graphicsUtils.BatchPart>} BATCH_POOL\n */\nvar BATCH_POOL = [];\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.BatchDrawCall>} DRAW_CALL_POOL\n */\nvar DRAW_CALL_POOL = [];\n\n/**\n * A class to contain data useful for Graphics objects\n *\n * @memberof PIXI\n */\nvar GraphicsData = /** @class */function () {\n  /**\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param fillStyle - the width of the line to draw\n   * @param lineStyle - the color of the line to draw\n   * @param matrix - Transform matrix\n   */\n  function GraphicsData(shape, fillStyle, lineStyle, matrix) {\n    if (fillStyle === void 0) {\n      fillStyle = null;\n    }\n    if (lineStyle === void 0) {\n      lineStyle = null;\n    }\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    /** The collection of points. */\n    this.points = [];\n    /** The collection of holes. */\n    this.holes = [];\n    this.shape = shape;\n    this.lineStyle = lineStyle;\n    this.fillStyle = fillStyle;\n    this.matrix = matrix;\n    this.type = shape.type;\n  }\n  /**\n   * Creates a new GraphicsData object with the same values as this one.\n   *\n   * @return - Cloned GraphicsData object\n   */\n  GraphicsData.prototype.clone = function () {\n    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n  };\n  /** Destroys the Graphics data. */\n  GraphicsData.prototype.destroy = function () {\n    this.shape = null;\n    this.holes.length = 0;\n    this.holes = null;\n    this.points.length = 0;\n    this.points = null;\n    this.lineStyle = null;\n    this.fillStyle = null;\n  };\n  return GraphicsData;\n}();\n\nvar tmpPoint = new _math.Point();\nvar tmpBounds = new _display.Bounds();\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n *\n * @memberof PIXI\n */\nvar GraphicsGeometry = /** @class */function (_super) {\n  __extends(GraphicsGeometry, _super);\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  function GraphicsGeometry() {\n    var _this = _super.call(this) || this;\n    /**\n     * Minimal distance between points that are considered different.\n     * Affects line tesselation.\n     */\n    _this.closePointEps = 1e-4;\n    /** Padding to add to the bounds. */\n    _this.boundsPadding = 0;\n    _this.uvsFloat32 = null;\n    _this.indicesUint16 = null;\n    _this.batchable = false;\n    /** An array of points to draw, 2 numbers per point */\n    _this.points = [];\n    /** The collection of colors */\n    _this.colors = [];\n    /** The UVs collection */\n    _this.uvs = [];\n    /** The indices of the vertices */\n    _this.indices = [];\n    /** Reference to the texture IDs. */\n    _this.textureIds = [];\n    /**\n     * The collection of drawn shapes.\n     *\n     * @member {PIXI.GraphicsData[]}\n     */\n    _this.graphicsData = [];\n    /**\n     * List of current draw calls drived from the batches.\n     *\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    _this.drawCalls = [];\n    /** Batches need to regenerated if the geometry is updated. */\n    _this.batchDirty = -1;\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     *\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    _this.batches = [];\n    /** Used to detect if the graphics object has changed. */\n    _this.dirty = 0;\n    /** Used to check if the cache is dirty. */\n    _this.cacheDirty = -1;\n    /** Used to detect if we cleared the graphicsData. */\n    _this.clearDirty = 0;\n    /** Index of the last batched shape in the stack of calls. */\n    _this.shapeIndex = 0;\n    /** Cached bounds. */\n    _this._bounds = new _display.Bounds();\n    /** The bounds dirty flag. */\n    _this.boundsDirty = -1;\n    return _this;\n  }\n  Object.defineProperty(GraphicsGeometry.prototype, \"bounds\", {\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @readonly\n     */\n    get: function () {\n      if (this.boundsDirty !== this.dirty) {\n        this.boundsDirty = this.dirty;\n        this.calculateBounds();\n      }\n      return this._bounds;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Call if you changed graphicsData manually.\n   * Empties all batch buffers.\n   */\n  GraphicsGeometry.prototype.invalidate = function () {\n    this.boundsDirty = -1;\n    this.dirty++;\n    this.batchDirty++;\n    this.shapeIndex = 0;\n    this.points.length = 0;\n    this.colors.length = 0;\n    this.uvs.length = 0;\n    this.indices.length = 0;\n    this.textureIds.length = 0;\n    for (var i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    for (var i = 0; i < this.batches.length; i++) {\n      var batchPart = this.batches[i];\n      batchPart.reset();\n      BATCH_POOL.push(batchPart);\n    }\n    this.batches.length = 0;\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   *\n   * @return - This GraphicsGeometry object. Good for chaining method calls\n   */\n  GraphicsGeometry.prototype.clear = function () {\n    if (this.graphicsData.length > 0) {\n      this.invalidate();\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n    return this;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param fillStyle - Defines style of the fill.\n   * @param lineStyle - Defines style of the lines.\n   * @param matrix - Transform applied to the points of the shape.\n   * @return - Returns geometry for chaining.\n   */\n  GraphicsGeometry.prototype.drawShape = function (shape, fillStyle, lineStyle, matrix) {\n    if (fillStyle === void 0) {\n      fillStyle = null;\n    }\n    if (lineStyle === void 0) {\n      lineStyle = null;\n    }\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    this.graphicsData.push(data);\n    this.dirty++;\n    return this;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param matrix - Transform applied to the points of the shape.\n   * @return - Returns geometry for chaining.\n   */\n  GraphicsGeometry.prototype.drawHole = function (shape, matrix) {\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    if (!this.graphicsData.length) {\n      return null;\n    }\n    var data = new GraphicsData(shape, null, null, matrix);\n    var lastShape = this.graphicsData[this.graphicsData.length - 1];\n    data.lineStyle = lastShape.lineStyle;\n    lastShape.holes.push(data);\n    this.dirty++;\n    return this;\n  };\n  /** Destroys the GraphicsGeometry object. */\n  GraphicsGeometry.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    // destroy each of the GraphicsData objects\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    }\n    this.points.length = 0;\n    this.points = null;\n    this.colors.length = 0;\n    this.colors = null;\n    this.uvs.length = 0;\n    this.uvs = null;\n    this.indices.length = 0;\n    this.indices = null;\n    this.indexBuffer.destroy();\n    this.indexBuffer = null;\n    this.graphicsData.length = 0;\n    this.graphicsData = null;\n    this.drawCalls.length = 0;\n    this.drawCalls = null;\n    this.batches.length = 0;\n    this.batches = null;\n    this._bounds = null;\n  };\n  /**\n   * Check to see if a point is contained within this geometry.\n   *\n   * @param point - Point to check if it's contained.\n   * @return {Boolean} `true` if the point is contained within geometry.\n   */\n  GraphicsGeometry.prototype.containsPoint = function (point) {\n    var graphicsData = this.graphicsData;\n    for (var i = 0; i < graphicsData.length; ++i) {\n      var data = graphicsData[i];\n      if (!data.fillStyle.visible) {\n        continue;\n      }\n      // only deal with fills..\n      if (data.shape) {\n        if (data.matrix) {\n          data.matrix.applyInverse(point, tmpPoint);\n        } else {\n          tmpPoint.copyFrom(point);\n        }\n        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n          var hitHole = false;\n          if (data.holes) {\n            for (var i_1 = 0; i_1 < data.holes.length; i_1++) {\n              var hole = data.holes[i_1];\n              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n  /**\n   * Generates intermediate batch data. Either gets converted to drawCalls\n   * or used to convert to batch objects directly by the Graphics object.\n   *\n   * @param allow32Indices - Allow using 32-bit indices for preventing artifacts when more that 65535 vertices\n   */\n  GraphicsGeometry.prototype.updateBatches = function (allow32Indices) {\n    if (!this.graphicsData.length) {\n      this.batchable = true;\n      return;\n    }\n    if (!this.validateBatching()) {\n      return;\n    }\n    this.cacheDirty = this.dirty;\n    var uvs = this.uvs;\n    var graphicsData = this.graphicsData;\n    var batchPart = null;\n    var currentStyle = null;\n    if (this.batches.length > 0) {\n      batchPart = this.batches[this.batches.length - 1];\n      currentStyle = batchPart.style;\n    }\n    for (var i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      var data = graphicsData[i];\n      var fillStyle = data.fillStyle;\n      var lineStyle = data.lineStyle;\n      var command = FILL_COMMANDS[data.type];\n      // build out the shapes points..\n      command.build(data);\n      if (data.matrix) {\n        this.transformPoints(data.points, data.matrix);\n      }\n      if (fillStyle.visible || lineStyle.visible) {\n        this.processHoles(data.holes);\n      }\n      for (var j = 0; j < 2; j++) {\n        var style = j === 0 ? fillStyle : lineStyle;\n        if (!style.visible) {\n          continue;\n        }\n        var nextTexture = style.texture.baseTexture;\n        var index_1 = this.indices.length;\n        var attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = _constants.WRAP_MODES.REPEAT;\n        if (j === 0) {\n          this.processFill(data);\n        } else {\n          this.processLine(data);\n        }\n        var size = this.points.length / 2 - attribIndex;\n        if (size === 0) {\n          continue;\n        }\n        // close batch if style is different\n        if (batchPart && !this._compareStyles(currentStyle, style)) {\n          batchPart.end(index_1, attribIndex);\n          batchPart = null;\n        }\n        // spawn new batch if its first batch or previous was closed\n        if (!batchPart) {\n          batchPart = BATCH_POOL.pop() || new BatchPart();\n          batchPart.begin(style, index_1, attribIndex);\n          this.batches.push(batchPart);\n          currentStyle = style;\n        }\n        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n      }\n    }\n    var index = this.indices.length;\n    var attrib = this.points.length / 2;\n    if (batchPart) {\n      batchPart.end(index, attrib);\n    }\n    if (this.batches.length === 0) {\n      // there are no visible styles in GraphicsData\n      // its possible that someone wants Graphics just for the bounds\n      this.batchable = true;\n      return;\n    }\n    // prevent allocation when length is same as buffer\n    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {\n      this.indicesUint16.set(this.indices);\n    } else {\n      var need32 = attrib > 0xffff && allow32Indices;\n      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n    }\n    // TODO make this a const..\n    this.batchable = this.isBatchable();\n    if (this.batchable) {\n      this.packBatches();\n    } else {\n      this.buildDrawCalls();\n    }\n  };\n  /**\n   * Affinity check\n   *\n   * @param styleA\n   * @param styleB\n   */\n  GraphicsGeometry.prototype._compareStyles = function (styleA, styleB) {\n    if (!styleA || !styleB) {\n      return false;\n    }\n    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n      return false;\n    }\n    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n      return false;\n    }\n    if (!!styleA.native !== !!styleB.native) {\n      return false;\n    }\n    return true;\n  };\n  /** Test geometry for batching process. */\n  GraphicsGeometry.prototype.validateBatching = function () {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n      return false;\n    }\n    for (var i = 0, l = this.graphicsData.length; i < l; i++) {\n      var data = this.graphicsData[i];\n      var fill = data.fillStyle;\n      var line = data.lineStyle;\n      if (fill && !fill.texture.baseTexture.valid) {\n        return false;\n      }\n      if (line && !line.texture.baseTexture.valid) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /** Offset the indices so that it works with the batcher. */\n  GraphicsGeometry.prototype.packBatches = function () {\n    this.batchDirty++;\n    this.uvsFloat32 = new Float32Array(this.uvs);\n    var batches = this.batches;\n    for (var i = 0, l = batches.length; i < l; i++) {\n      var batch = batches[i];\n      for (var j = 0; j < batch.size; j++) {\n        var index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  };\n  /**\n   * Checks to see if this graphics geometry can be batched.\n   * Currently it needs to be small enough and not contain any native lines.\n   */\n  GraphicsGeometry.prototype.isBatchable = function () {\n    // prevent heavy mesh batching\n    if (this.points.length > 0xffff * 2) {\n      return false;\n    }\n    var batches = this.batches;\n    for (var i = 0; i < batches.length; i++) {\n      if (batches[i].style.native) {\n        return false;\n      }\n    }\n    return this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2;\n  };\n  /** Converts intermediate batches data to drawCalls. */\n  GraphicsGeometry.prototype.buildDrawCalls = function () {\n    var TICK = ++_core.BaseTexture._globalBatch;\n    for (var i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    var colors = this.colors;\n    var textureIds = this.textureIds;\n    var currentGroup = DRAW_CALL_POOL.pop();\n    if (!currentGroup) {\n      currentGroup = new _core.BatchDrawCall();\n      currentGroup.texArray = new _core.BatchTextureArray();\n    }\n    currentGroup.texArray.count = 0;\n    currentGroup.start = 0;\n    currentGroup.size = 0;\n    currentGroup.type = _constants.DRAW_MODES.TRIANGLES;\n    var textureCount = 0;\n    var currentTexture = null;\n    var textureId = 0;\n    var native = false;\n    var drawMode = _constants.DRAW_MODES.TRIANGLES;\n    var index = 0;\n    this.drawCalls.push(currentGroup);\n    // TODO - this can be simplified\n    for (var i = 0; i < this.batches.length; i++) {\n      var data = this.batches[i];\n      // TODO add some full on MAX_TEXTURE CODE..\n      var MAX_TEXTURES = 8;\n      // Forced cast for checking `native` without errors\n      var style = data.style;\n      var nextTexture = style.texture.baseTexture;\n      if (native !== !!style.native) {\n        native = !!style.native;\n        drawMode = native ? _constants.DRAW_MODES.LINES : _constants.DRAW_MODES.TRIANGLES;\n        // force the batch to break!\n        currentTexture = null;\n        textureCount = MAX_TEXTURES;\n        TICK++;\n      }\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n        if (nextTexture._batchEnabled !== TICK) {\n          if (textureCount === MAX_TEXTURES) {\n            TICK++;\n            textureCount = 0;\n            if (currentGroup.size > 0) {\n              currentGroup = DRAW_CALL_POOL.pop();\n              if (!currentGroup) {\n                currentGroup = new _core.BatchDrawCall();\n                currentGroup.texArray = new _core.BatchTextureArray();\n              }\n              this.drawCalls.push(currentGroup);\n            }\n            currentGroup.start = index;\n            currentGroup.size = 0;\n            currentGroup.texArray.count = 0;\n            currentGroup.type = drawMode;\n          }\n          // TODO add this to the render part..\n          // Hack! Because texture has protected `touched`\n          nextTexture.touched = 1; // touch;\n          nextTexture._batchEnabled = TICK;\n          nextTexture._batchLocation = textureCount;\n          nextTexture.wrapMode = _constants.WRAP_MODES.REPEAT;\n          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n          textureCount++;\n        }\n      }\n      currentGroup.size += data.size;\n      index += data.size;\n      textureId = nextTexture._batchLocation;\n      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n    }\n    _core.BaseTexture._globalBatch = TICK;\n    // upload..\n    // merge for now!\n    this.packAttributes();\n  };\n  /** Packs attributes to single buffer. */\n  GraphicsGeometry.prototype.packAttributes = function () {\n    var verts = this.points;\n    var uvs = this.uvs;\n    var colors = this.colors;\n    var textureIds = this.textureIds;\n    // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n    var glPoints = new ArrayBuffer(verts.length * 3 * 4);\n    var f32 = new Float32Array(glPoints);\n    var u32 = new Uint32Array(glPoints);\n    var p = 0;\n    for (var i = 0; i < verts.length / 2; i++) {\n      f32[p++] = verts[i * 2];\n      f32[p++] = verts[i * 2 + 1];\n      f32[p++] = uvs[i * 2];\n      f32[p++] = uvs[i * 2 + 1];\n      u32[p++] = colors[i];\n      f32[p++] = textureIds[i];\n    }\n    this._buffer.update(glPoints);\n    this._indexBuffer.update(this.indicesUint16);\n  };\n  /** Process fill part of Graphics. */\n  GraphicsGeometry.prototype.processFill = function (data) {\n    if (data.holes.length) {\n      buildPoly.triangulate(data, this);\n    } else {\n      var command = FILL_COMMANDS[data.type];\n      command.triangulate(data, this);\n    }\n  };\n  /** Process line part of Graphics. */\n  GraphicsGeometry.prototype.processLine = function (data) {\n    buildLine(data, this);\n    for (var i = 0; i < data.holes.length; i++) {\n      buildLine(data.holes[i], this);\n    }\n  };\n  /** Process the holes data. */\n  GraphicsGeometry.prototype.processHoles = function (holes) {\n    for (var i = 0; i < holes.length; i++) {\n      var hole = holes[i];\n      var command = FILL_COMMANDS[hole.type];\n      command.build(hole);\n      if (hole.matrix) {\n        this.transformPoints(hole.points, hole.matrix);\n      }\n    }\n  };\n  /** Update the local bounds of the object. Expensive to use performance-wise. */\n  GraphicsGeometry.prototype.calculateBounds = function () {\n    var bounds = this._bounds;\n    var sequenceBounds = tmpBounds;\n    var curMatrix = _math.Matrix.IDENTITY;\n    this._bounds.clear();\n    sequenceBounds.clear();\n    for (var i = 0; i < this.graphicsData.length; i++) {\n      var data = this.graphicsData[i];\n      var shape = data.shape;\n      var type = data.type;\n      var lineStyle = data.lineStyle;\n      var nextMatrix = data.matrix || _math.Matrix.IDENTITY;\n      var lineWidth = 0.0;\n      if (lineStyle && lineStyle.visible) {\n        lineWidth = lineStyle.width;\n        if (type !== _math.SHAPES.POLY || data.fillStyle.visible) {\n          lineWidth *= Math.max(0, lineStyle.alignment);\n        } else {\n          lineWidth *= Math.max(lineStyle.alignment, 1 - lineStyle.alignment);\n        }\n      }\n      if (curMatrix !== nextMatrix) {\n        if (!sequenceBounds.isEmpty()) {\n          bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n          sequenceBounds.clear();\n        }\n        curMatrix = nextMatrix;\n      }\n      if (type === _math.SHAPES.RECT || type === _math.SHAPES.RREC) {\n        var rect = shape;\n        sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);\n      } else if (type === _math.SHAPES.CIRC) {\n        var circle = shape;\n        sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);\n      } else if (type === _math.SHAPES.ELIP) {\n        var ellipse = shape;\n        sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);\n      } else {\n        var poly = shape;\n        // adding directly to the bounds\n        bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);\n      }\n    }\n    if (!sequenceBounds.isEmpty()) {\n      bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n    }\n    bounds.pad(this.boundsPadding, this.boundsPadding);\n  };\n  /**\n   * Transform points using matrix.\n   *\n   * @param points - Points to transform\n   * @param matrix - Transform matrix\n   */\n  GraphicsGeometry.prototype.transformPoints = function (points, matrix) {\n    for (var i = 0; i < points.length / 2; i++) {\n      var x = points[i * 2];\n      var y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  };\n  /**\n   * Add colors.\n   *\n   * @param colors - List of colors to add to\n   * @param color - Color to add\n   * @param alpha - Alpha to use\n   * @param size - Number of colors to add\n   * @param offset\n   */\n  GraphicsGeometry.prototype.addColors = function (colors, color, alpha, size, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    // TODO use the premultiply bits Ivan added\n    var rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n    var rgba = (0, _utils.premultiplyTint)(rgb, alpha);\n    colors.length = Math.max(colors.length, offset + size);\n    for (var i = 0; i < size; i++) {\n      colors[offset + i] = rgba;\n    }\n  };\n  /** Add texture id that the shader/fragment wants to use. */\n  GraphicsGeometry.prototype.addTextureIds = function (textureIds, id, size, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    textureIds.length = Math.max(textureIds.length, offset + size);\n    for (var i = 0; i < size; i++) {\n      textureIds[offset + i] = id;\n    }\n  };\n  /**\n   * Generates the UVs for a shape.\n   *\n   * @param verts - Vertices\n   * @param uvs - UVs\n   * @param texture - Reference to Texture\n   * @param start - Index buffer start index.\n   * @param size - The size/length for index buffer.\n   * @param matrix - Optional transform for all points.\n   */\n  GraphicsGeometry.prototype.addUvs = function (verts, uvs, texture, start, size, matrix) {\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    var index = 0;\n    var uvsStart = uvs.length;\n    var frame = texture.frame;\n    while (index < size) {\n      var x = verts[(start + index) * 2];\n      var y = verts[(start + index) * 2 + 1];\n      if (matrix) {\n        var nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty;\n        x = nx;\n      }\n      index++;\n      uvs.push(x / frame.width, y / frame.height);\n    }\n    var baseTexture = texture.baseTexture;\n    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n      this.adjustUvs(uvs, texture, uvsStart, size);\n    }\n  };\n  /**\n   * Modify uvs array according to position of texture region\n   * Does not work with rotated or trimmed textures\n   *\n   * @param uvs - array\n   * @param texture - region\n   * @param start - starting index for uvs\n   * @param size - how many points to adjust\n   */\n  GraphicsGeometry.prototype.adjustUvs = function (uvs, texture, start, size) {\n    var baseTexture = texture.baseTexture;\n    var eps = 1e-6;\n    var finish = start + size * 2;\n    var frame = texture.frame;\n    var scaleX = frame.width / baseTexture.width;\n    var scaleY = frame.height / baseTexture.height;\n    var offsetX = frame.x / frame.width;\n    var offsetY = frame.y / frame.height;\n    var minX = Math.floor(uvs[start] + eps);\n    var minY = Math.floor(uvs[start + 1] + eps);\n    for (var i = start + 2; i < finish; i += 2) {\n      minX = Math.min(minX, Math.floor(uvs[i] + eps));\n      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    }\n    offsetX -= minX;\n    offsetY -= minY;\n    for (var i = start; i < finish; i += 2) {\n      uvs[i] = (uvs[i] + offsetX) * scaleX;\n      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n    }\n  };\n  /**\n   * The maximum number of points to consider an object \"batchable\",\n   * able to be batched by the renderer's batch system.\n  \\    */\n  GraphicsGeometry.BATCHABLE_SIZE = 100;\n  return GraphicsGeometry;\n}(_core.BatchGeometry);\n\n/**\n * Represents the line style for Graphics.\n *\n * @memberof PIXI\n */\nvar LineStyle = /** @class */function (_super) {\n  __extends(LineStyle, _super);\n  function LineStyle() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** The width (thickness) of any lines drawn. */\n    _this.width = 0;\n    /** The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner). WebGL only. */\n    _this.alignment = 0.5;\n    /** If true the lines will be draw using LINES instead of TRIANGLE_STRIP. */\n    _this.native = false;\n    /**\n     * Line cap style.\n     *\n     * @member {PIXI.LINE_CAP}\n     * @default PIXI.LINE_CAP.BUTT\n     */\n    _this.cap = LINE_CAP.BUTT;\n    /**\n     * Line join style.\n     *\n     * @member {PIXI.LINE_JOIN}\n     * @default PIXI.LINE_JOIN.MITER\n     */\n    _this.join = LINE_JOIN.MITER;\n    /** Miter limit. */\n    _this.miterLimit = 10;\n    return _this;\n  }\n  /** Clones the object. */\n  LineStyle.prototype.clone = function () {\n    var obj = new LineStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    obj.width = this.width;\n    obj.alignment = this.alignment;\n    obj.native = this.native;\n    obj.cap = this.cap;\n    obj.join = this.join;\n    obj.miterLimit = this.miterLimit;\n    return obj;\n  };\n  /** Reset the line style to default. */\n  LineStyle.prototype.reset = function () {\n    _super.prototype.reset.call(this);\n    // Override default line style color\n    this.color = 0x0;\n    this.alignment = 0.5;\n    this.width = 0;\n    this.native = false;\n  };\n  return LineStyle;\n}(FillStyle);\n\nvar temp = new Float32Array(3);\n// a default shaders map used by graphics..\nvar DEFAULT_SHADERS = {};\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n *\n * Please note that due to legacy naming conventions, the behavior of some functions in this class\n * can be confusing.  Each call to `drawRect()`, `drawPolygon()`, etc. actually stores that primitive\n * in the Geometry class's GraphicsGeometry object for later use in rendering or hit testing - the\n * functions do not directly draw anything to the screen.  Similarly, the `clear()` function doesn't\n * change the screen, it simply resets the list of primitives, which can be useful if you want to\n * rebuild the contents of an existing Graphics object.\n *\n * Once a GraphicsGeometry list is built, you can re-use it in other Geometry objects as\n * an optimization, by passing it into a new Geometry object's constructor.  Because of this\n * ability, it's important to call `destroy()` on Geometry objects once you are done with them, to\n * properly dereference each GraphicsGeometry and prevent memory leaks.\n *\n * @memberof PIXI\n */\nvar Graphics = /** @class */function (_super) {\n  __extends(Graphics, _super);\n  /**\n   * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.\n   */\n  function Graphics(geometry) {\n    if (geometry === void 0) {\n      geometry = null;\n    }\n    var _this = _super.call(this) || this;\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Graphics objects.\n     */\n    _this.shader = null;\n    /** Renderer plugin for batching */\n    _this.pluginName = 'batch';\n    /**\n     * Current path\n     *\n     * @readonly\n     */\n    _this.currentPath = null;\n    /** A collections of batches! These can be drawn by the renderer batch system. */\n    _this.batches = [];\n    /** Update dirty for limiting calculating tints for batches. */\n    _this.batchTint = -1;\n    /** Update dirty for limiting calculating batches.*/\n    _this.batchDirty = -1;\n    /** Copy of the object vertex data. */\n    _this.vertexData = null;\n    /** Current fill style. */\n    _this._fillStyle = new FillStyle();\n    /** Current line style. */\n    _this._lineStyle = new LineStyle();\n    /** Current shape transform matrix. */\n    _this._matrix = null;\n    /** Current hole mode is enabled. */\n    _this._holeMode = false;\n    /**\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    _this.state = _core.State.for2d();\n    _this._geometry = geometry || new GraphicsGeometry();\n    _this._geometry.refCount++;\n    /**\n     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n     * This is useful if your graphics element does not change often, as it will speed up the rendering\n     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n     * you are constantly redrawing the graphics element.\n     *\n     * @name cacheAsBitmap\n     * @member {boolean}\n     * @memberof PIXI.Graphics#\n     * @default false\n     */\n    _this._transformID = -1;\n    // Set default\n    _this.tint = 0xFFFFFF;\n    _this.blendMode = _constants.BLEND_MODES.NORMAL;\n    return _this;\n  }\n  Object.defineProperty(Graphics.prototype, \"geometry\", {\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     *\n     * @readonly\n     */\n    get: function () {\n      return this._geometry;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a new Graphics object with the same values as this one.\n   * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n   *\n   * @return - A clone of the graphics object\n   */\n  Graphics.prototype.clone = function () {\n    this.finishPoly();\n    return new Graphics(this._geometry);\n  };\n  Object.defineProperty(Graphics.prototype, \"blendMode\", {\n    get: function () {\n      return this.state.blendMode;\n    },\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n     * primitive in the GraphicsGeometry list is rendered sequentially, modes\n     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n     * be applied per-primitive.\n     *\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    set: function (value) {\n      this.state.blendMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"tint\", {\n    /**\n     * The tint applied to each graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     *\n     * @default 0xFFFFFF\n     */\n    get: function () {\n      return this._tint;\n    },\n    set: function (value) {\n      this._tint = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"fill\", {\n    /**\n     * The current fill style.\n     *\n     * @readonly\n     */\n    get: function () {\n      return this._fillStyle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"line\", {\n    /**\n     * The current line style.\n     *\n     * @readonly\n     */\n    get: function () {\n      return this._lineStyle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Graphics.prototype.lineStyle = function (options, color, alpha, alignment, native) {\n    if (options === void 0) {\n      options = null;\n    }\n    if (color === void 0) {\n      color = 0x0;\n    }\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n    if (alignment === void 0) {\n      alignment = 0.5;\n    }\n    if (native === void 0) {\n      native = false;\n    }\n    // Support non-object params: (width, color, alpha, alignment, native)\n    if (typeof options === 'number') {\n      options = { width: options, color: color, alpha: alpha, alignment: alignment, native: native };\n    }\n    return this.lineTextureStyle(options);\n  };\n  /**\n   * Like line style but support texture for line fill.\n   *\n   * @param options - Collection of options for setting line style.\n   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n   * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n   *  Default 0xFFFFFF if texture present.\n   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n   *        WebGL only.\n   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n   * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n   * @param {number}[options.miterLimit=10] - miter limit ratio\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.lineTextureStyle = function (options) {\n    // Apply defaults\n    options = Object.assign({\n      width: 0,\n      texture: _core.Texture.WHITE,\n      color: options && options.texture ? 0xFFFFFF : 0x0,\n      alpha: 1,\n      matrix: null,\n      alignment: 0.5,\n      native: false,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    }, options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    var visible = options.width > 0 && options.alpha > 0;\n    if (!visible) {\n      this._lineStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._lineStyle, { visible: visible }, options);\n    }\n    return this;\n  };\n  /**\n   * Start a polygon object internally.\n   *\n   * @protected\n   */\n  Graphics.prototype.startPoly = function () {\n    if (this.currentPath) {\n      var points = this.currentPath.points;\n      var len = this.currentPath.points.length;\n      if (len > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = new _math.Polygon();\n        this.currentPath.closeStroke = false;\n        this.currentPath.points.push(points[len - 2], points[len - 1]);\n      }\n    } else {\n      this.currentPath = new _math.Polygon();\n      this.currentPath.closeStroke = false;\n    }\n  };\n  /**\n   * Finish the polygon object.\n   *\n   * @protected\n   */\n  Graphics.prototype.finishPoly = function () {\n    if (this.currentPath) {\n      if (this.currentPath.points.length > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = null;\n      } else {\n        this.currentPath.points.length = 0;\n      }\n    }\n  };\n  /**\n   * Moves the current drawing position to x, y.\n   *\n   * @param x - the X coordinate to move to\n   * @param y - the Y coordinate to move to\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.moveTo = function (x, y) {\n    this.startPoly();\n    this.currentPath.points[0] = x;\n    this.currentPath.points[1] = y;\n    return this;\n  };\n  /**\n   * Draws a line using the current line style from the current drawing position to (x, y);\n   * The current drawing position is then set to (x, y).\n   *\n   * @param x - the X coordinate to draw to\n   * @param y - the Y coordinate to draw to\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.lineTo = function (x, y) {\n    if (!this.currentPath) {\n      this.moveTo(0, 0);\n    }\n    // remove duplicates..\n    var points = this.currentPath.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  };\n  /** Initialize the curve */\n  Graphics.prototype._initCurve = function (x, y) {\n    if (x === void 0) {\n      x = 0;\n    }\n    if (y === void 0) {\n      y = 0;\n    }\n    if (this.currentPath) {\n      if (this.currentPath.points.length === 0) {\n        this.currentPath.points = [x, y];\n      }\n    } else {\n      this.moveTo(x, y);\n    }\n  };\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   *\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY) {\n    this._initCurve();\n    var points = this.currentPath.points;\n    if (points.length === 0) {\n      this.moveTo(0, 0);\n    }\n    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n    return this;\n  };\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @return This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._initCurve();\n    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n    return this;\n  };\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   *\n   * @param x1 - The x-coordinate of the first tangent point of the arc\n   * @param y1 - The y-coordinate of the first tangent point of the arc\n   * @param x2 - The x-coordinate of the end of the arc\n   * @param y2 - The y-coordinate of the end of the arc\n   * @param radius - The radius of the arc\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n    this._initCurve(x1, y1);\n    var points = this.currentPath.points;\n    var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n    if (result) {\n      var cx = result.cx,\n          cy = result.cy,\n          radius_1 = result.radius,\n          startAngle = result.startAngle,\n          endAngle = result.endAngle,\n          anticlockwise = result.anticlockwise;\n      this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);\n    }\n    return this;\n  };\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   *\n   * @param cx - The x-coordinate of the center of the circle\n   * @param cy - The y-coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param endAngle - The ending angle, in radians\n   * @param anticlockwise - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.arc = function (cx, cy, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise === void 0) {\n      anticlockwise = false;\n    }\n    if (startAngle === endAngle) {\n      return this;\n    }\n    if (!anticlockwise && endAngle <= startAngle) {\n      endAngle += _math.PI_2;\n    } else if (anticlockwise && startAngle <= endAngle) {\n      startAngle += _math.PI_2;\n    }\n    var sweep = endAngle - startAngle;\n    if (sweep === 0) {\n      return this;\n    }\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n    var eps = this._geometry.closePointEps;\n    // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n    var points = this.currentPath ? this.currentPath.points : null;\n    if (points) {\n      // TODO: make a better fix.\n      // We check how far our start is from the last existing point\n      var xDiff = Math.abs(points[points.length - 2] - startX);\n      var yDiff = Math.abs(points[points.length - 1] - startY);\n      if (xDiff < eps && yDiff < eps) ;else {\n        points.push(startX, startY);\n      }\n    } else {\n      this.moveTo(startX, startY);\n      points = this.currentPath.points;\n    }\n    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n    return this;\n  };\n  /**\n   * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n   * (such as lineTo() or drawCircle()) use when drawing.\n   *\n   * @param color - the color of the fill\n   * @param alpha - the alpha of the fill\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.beginFill = function (color, alpha) {\n    if (color === void 0) {\n      color = 0;\n    }\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n    return this.beginTextureFill({ texture: _core.Texture.WHITE, color: color, alpha: alpha });\n  };\n  /**\n   * Begin the texture fill\n   *\n   * @param options - Object object.\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n   * @param {number} [options.color=0xffffff] - Background to fill behind texture\n   * @param {number} [options.alpha=1] - Alpha of fill\n   * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.beginTextureFill = function (options) {\n    // Apply defaults\n    options = Object.assign({\n      texture: _core.Texture.WHITE,\n      color: 0xFFFFFF,\n      alpha: 1,\n      matrix: null\n    }, options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    var visible = options.alpha > 0;\n    if (!visible) {\n      this._fillStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._fillStyle, { visible: visible }, options);\n    }\n    return this;\n  };\n  /**\n   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n   *\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.endFill = function () {\n    this.finishPoly();\n    this._fillStyle.reset();\n    return this;\n  };\n  /**\n   * Draws a rectangle shape.\n   *\n   * @param x - The X coord of the top-left of the rectangle\n   * @param y - The Y coord of the top-left of the rectangle\n   * @param width - The width of the rectangle\n   * @param height - The height of the rectangle\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawRect = function (x, y, width, height) {\n    return this.drawShape(new _math.Rectangle(x, y, width, height));\n  };\n  /**\n   * Draw a rectangle shape with rounded/beveled corners.\n   *\n   * @param x - The X coord of the top-left of the rectangle\n   * @param y - The Y coord of the top-left of the rectangle\n   * @param width - The width of the rectangle\n   * @param height - The height of the rectangle\n   * @param radius - Radius of the rectangle corners\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawRoundedRect = function (x, y, width, height, radius) {\n    return this.drawShape(new _math.RoundedRectangle(x, y, width, height, radius));\n  };\n  /**\n   * Draws a circle.\n   *\n   * @param x - The X coordinate of the center of the circle\n   * @param y - The Y coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawCircle = function (x, y, radius) {\n    return this.drawShape(new _math.Circle(x, y, radius));\n  };\n  /**\n   * Draws an ellipse.\n   *\n   * @param x - The X coordinate of the center of the ellipse\n   * @param y - The Y coordinate of the center of the ellipse\n   * @param width - The half width of the ellipse\n   * @param height - The half height of the ellipse\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawEllipse = function (x, y, width, height) {\n    return this.drawShape(new _math.Ellipse(x, y, width, height));\n  };\n  /**\n   * Draws a polygon using the given path.\n   *\n   * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawPolygon = function () {\n    var arguments$1 = arguments;\n\n    var path = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      path[_i] = arguments$1[_i];\n    }\n    var points;\n    var closeStroke = true; // !!this._fillStyle;\n    var poly = path[0];\n    // check if data has points..\n    if (poly.points) {\n      closeStroke = poly.closeStroke;\n      points = poly.points;\n    } else if (Array.isArray(path[0])) {\n      points = path[0];\n    } else {\n      points = path;\n    }\n    var shape = new _math.Polygon(points);\n    shape.closeStroke = closeStroke;\n    this.drawShape(shape);\n    return this;\n  };\n  /**\n   * Draw any shape.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawShape = function (shape) {\n    if (!this._holeMode) {\n      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);\n    } else {\n      this._geometry.drawHole(shape, this._matrix);\n    }\n    return this;\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   *\n   * @return - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.clear = function () {\n    this._geometry.clear();\n    this._lineStyle.reset();\n    this._fillStyle.reset();\n    this._boundsID++;\n    this._matrix = null;\n    this._holeMode = false;\n    this.currentPath = null;\n    return this;\n  };\n  /**\n   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n   * masked with gl.scissor.\n   *\n   * @returns - True if only 1 rect.\n   */\n  Graphics.prototype.isFastRect = function () {\n    var data = this._geometry.graphicsData;\n    return data.length === 1 && data[0].shape.type === _math.SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param renderer - The renderer\n   */\n  Graphics.prototype._render = function (renderer) {\n    this.finishPoly();\n    var geometry = this._geometry;\n    var hasuint32 = renderer.context.supports.uint32Indices;\n    // batch part..\n    // batch it!\n    geometry.updateBatches(hasuint32);\n    if (geometry.batchable) {\n      if (this.batchDirty !== geometry.batchDirty) {\n        this._populateBatches();\n      }\n      this._renderBatched(renderer);\n    } else {\n      // no batching...\n      renderer.batch.flush();\n      this._renderDirect(renderer);\n    }\n  };\n  /** Populating batches for rendering. */\n  Graphics.prototype._populateBatches = function () {\n    var geometry = this._geometry;\n    var blendMode = this.blendMode;\n    var len = geometry.batches.length;\n    this.batchTint = -1;\n    this._transformID = -1;\n    this.batchDirty = geometry.batchDirty;\n    this.batches.length = len;\n    this.vertexData = new Float32Array(geometry.points);\n    for (var i = 0; i < len; i++) {\n      var gI = geometry.batches[i];\n      var color = gI.style.color;\n      var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);\n      var batch = {\n        vertexData: vertexData,\n        blendMode: blendMode,\n        indices: indices,\n        uvs: uvs,\n        _batchRGB: (0, _utils.hex2rgb)(color),\n        _tintRGB: color,\n        _texture: gI.style.texture,\n        alpha: gI.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[i] = batch;\n    }\n  };\n  /**\n   * Renders the batches using the BathedRenderer plugin\n   *\n   * @param renderer - The renderer\n   */\n  Graphics.prototype._renderBatched = function (renderer) {\n    if (!this.batches.length) {\n      return;\n    }\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    this.calculateVertices();\n    this.calculateTints();\n    for (var i = 0, l = this.batches.length; i < l; i++) {\n      var batch = this.batches[i];\n      batch.worldAlpha = this.worldAlpha * batch.alpha;\n      renderer.plugins[this.pluginName].render(batch);\n    }\n  };\n  /**\n   * Renders the graphics direct\n   *\n   * @param renderer - The renderer\n   */\n  Graphics.prototype._renderDirect = function (renderer) {\n    var shader = this._resolveDirectShader(renderer);\n    var geometry = this._geometry;\n    var tint = this.tint;\n    var worldAlpha = this.worldAlpha;\n    var uniforms = shader.uniforms;\n    var drawCalls = geometry.drawCalls;\n    // lets set the transfomr\n    uniforms.translationMatrix = this.transform.worldTransform;\n    // and then lets set the tint..\n    uniforms.tint[0] = (tint >> 16 & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[1] = (tint >> 8 & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[2] = (tint & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[3] = worldAlpha;\n    // the first draw call, we can set the uniforms of the shader directly here.\n    // this means that we can tack advantage of the sync function of pixi!\n    // bind and sync uniforms..\n    // there is a way to optimise this..\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(geometry, shader);\n    // set state..\n    renderer.state.set(this.state);\n    // then render the rest of them...\n    for (var i = 0, l = drawCalls.length; i < l; i++) {\n      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n    }\n  };\n  /** Renders specific DrawCall */\n  Graphics.prototype._renderDrawCallDirect = function (renderer, drawCall) {\n    var texArray = drawCall.texArray,\n        type = drawCall.type,\n        size = drawCall.size,\n        start = drawCall.start;\n    var groupTextureCount = texArray.count;\n    for (var j = 0; j < groupTextureCount; j++) {\n      renderer.texture.bind(texArray.elements[j], j);\n    }\n    renderer.geometry.draw(type, size, start);\n  };\n  /**\n   * Resolves shader for direct rendering\n   *\n   * @param renderer - The renderer\n   */\n  Graphics.prototype._resolveDirectShader = function (renderer) {\n    var shader = this.shader;\n    var pluginName = this.pluginName;\n    if (!shader) {\n      // if there is no shader here, we can use the default shader.\n      // and that only gets created if we actually need it..\n      // but may be more than one plugins for graphics\n      if (!DEFAULT_SHADERS[pluginName]) {\n        var MAX_TEXTURES = renderer.plugins[pluginName].MAX_TEXTURES;\n        var sampleValues = new Int32Array(MAX_TEXTURES);\n        for (var i = 0; i < MAX_TEXTURES; i++) {\n          sampleValues[i] = i;\n        }\n        var uniforms = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new _math.Matrix(),\n          default: _core.UniformGroup.from({ uSamplers: sampleValues }, true)\n        };\n        var program = renderer.plugins[pluginName]._shader.program;\n        DEFAULT_SHADERS[pluginName] = new _core.Shader(program, uniforms);\n      }\n      shader = DEFAULT_SHADERS[pluginName];\n    }\n    return shader;\n  };\n  /** Retrieves the bounds of the graphic shape as a rectangle object. */\n  Graphics.prototype._calculateBounds = function () {\n    this.finishPoly();\n    var geometry = this._geometry;\n    // skipping when graphics is empty, like a container\n    if (!geometry.graphicsData.length) {\n      return;\n    }\n    var _a = geometry.bounds,\n        minX = _a.minX,\n        minY = _a.minY,\n        maxX = _a.maxX,\n        maxY = _a.maxY;\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  /**\n   * Tests if a point is inside this graphics object\n   *\n   * @param point - the point to test\n   * @return - the result of the test\n   */\n  Graphics.prototype.containsPoint = function (point) {\n    this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n    return this._geometry.containsPoint(Graphics._TEMP_POINT);\n  };\n  /** Recalculate the tint by applying tint to batches using Graphics tint. */\n  Graphics.prototype.calculateTints = function () {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this.tint;\n      var tintRGB = (0, _utils.hex2rgb)(this.tint, temp);\n      for (var i = 0; i < this.batches.length; i++) {\n        var batch = this.batches[i];\n        var batchTint = batch._batchRGB;\n        var r = tintRGB[0] * batchTint[0] * 255;\n        var g = tintRGB[1] * batchTint[1] * 255;\n        var b = tintRGB[2] * batchTint[2] * 255;\n        // TODO Ivan, can this be done in one go?\n        var color = (r << 16) + (g << 8) + (b | 0);\n        batch._tintRGB = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n      }\n    }\n  };\n  /**\n   * If there's a transform update or a change to the shape of the\n   * geometry, recalculate the vertices.\n   */\n  Graphics.prototype.calculateVertices = function () {\n    var wtID = this.transform._worldID;\n    if (this._transformID === wtID) {\n      return;\n    }\n    this._transformID = wtID;\n    var wt = this.transform.worldTransform;\n    var a = wt.a;\n    var b = wt.b;\n    var c = wt.c;\n    var d = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var data = this._geometry.points; // batch.vertexDataOriginal;\n    var vertexData = this.vertexData;\n    var count = 0;\n    for (var i = 0; i < data.length; i += 2) {\n      var x = data[i];\n      var y = data[i + 1];\n      vertexData[count++] = a * x + c * y + tx;\n      vertexData[count++] = d * y + b * x + ty;\n    }\n  };\n  /**\n   * Closes the current path.\n   *\n   * @return - Returns itself.\n   */\n  Graphics.prototype.closePath = function () {\n    var currentPath = this.currentPath;\n    if (currentPath) {\n      // we don't need to add extra point in the end because buildLine will take care of that\n      currentPath.closeStroke = true;\n      // ensure that the polygon is completed, and is available for hit detection\n      // (even if the graphics is not rendered yet)\n      this.finishPoly();\n    }\n    return this;\n  };\n  /**\n   * Apply a matrix to the positional data.\n   *\n   * @param matrix - Matrix to use for transform current shape.\n   * @return - Returns itself.\n   */\n  Graphics.prototype.setMatrix = function (matrix) {\n    this._matrix = matrix;\n    return this;\n  };\n  /**\n   * Begin adding holes to the last draw shape\n   * IMPORTANT: holes must be fully inside a shape to work\n   * Also weirdness ensues if holes overlap!\n   * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n   * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n   *\n   * @return - Returns itself.\n   */\n  Graphics.prototype.beginHole = function () {\n    this.finishPoly();\n    this._holeMode = true;\n    return this;\n  };\n  /**\n   * End adding holes to the last draw shape.\n   *\n   * @return - Returns itself.\n   */\n  Graphics.prototype.endHole = function () {\n    this.finishPoly();\n    this._holeMode = false;\n    return this;\n  };\n  /**\n   * Destroys the Graphics object.\n   *\n   * @param options - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  Graphics.prototype.destroy = function (options) {\n    this._geometry.refCount--;\n    if (this._geometry.refCount === 0) {\n      this._geometry.dispose();\n    }\n    this._matrix = null;\n    this.currentPath = null;\n    this._lineStyle.destroy();\n    this._lineStyle = null;\n    this._fillStyle.destroy();\n    this._fillStyle = null;\n    this._geometry = null;\n    this.shader = null;\n    this.vertexData = null;\n    this.batches.length = 0;\n    this.batches = null;\n    _super.prototype.destroy.call(this, options);\n  };\n  /**\n   * New rendering behavior for rounded rectangles: circular arcs instead of quadratic bezier curves.\n   * In the next major release, we'll enable this by default.\n   */\n  Graphics.nextRoundedRectBehavior = false;\n  /**\n   * Temporary point to use for containsPoint.\n   *\n   * @private\n   */\n  Graphics._TEMP_POINT = new _math.Point();\n  return Graphics;\n}(_display.Container);\n\nvar graphicsUtils = {\n  buildPoly: buildPoly,\n  buildCircle: buildCircle,\n  buildRectangle: buildRectangle,\n  buildRoundedRectangle: buildRoundedRectangle,\n  buildLine: buildLine,\n  ArcUtils: ArcUtils,\n  BezierUtils: BezierUtils,\n  QuadraticUtils: QuadraticUtils,\n  BatchPart: BatchPart,\n  FILL_COMMANDS: FILL_COMMANDS,\n  BATCH_POOL: BATCH_POOL,\n  DRAW_CALL_POOL: DRAW_CALL_POOL\n};\n\nexports.FillStyle = FillStyle;\nexports.GRAPHICS_CURVES = GRAPHICS_CURVES;\nexports.Graphics = Graphics;\nexports.GraphicsData = GraphicsData;\nexports.GraphicsGeometry = GraphicsGeometry;\nexports.LINE_CAP = LINE_CAP;\nexports.LINE_JOIN = LINE_JOIN;\nexports.LineStyle = LineStyle;\nexports.graphicsUtils = graphicsUtils;\n//# sourceMappingURL=graphics.js.map"},"hash":"8f6c7565bab960b4506b033fd1c6f24a"}