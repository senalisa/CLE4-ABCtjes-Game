{"dependencies":[{"name":"@pixi/core","loc":{"line":8,"column":24}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TextureLoader = exports.LoaderResource = exports.Loader = exports.AppLoaderPlugin = undefined;\n\nvar _core = require(\"@pixi/core\");\n\n/* jshint -W097 */\n/**\n * @memberof PIXI\n */\nvar SignalBinding = /** @class */function () {\n  /**\n   * SignalBinding constructor.\n   * @constructs SignalBinding\n   * @param {Function} fn - Event handler to be called.\n   * @param {Boolean} [once=false] - Should this listener be removed after dispatch\n   * @param {object} [thisArg] - The context of the callback function.\n   * @api private\n   */\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  function SignalBinding(fn, once, thisArg) {\n    if (once === void 0) {\n      once = false;\n    }\n    this._fn = fn;\n    this._once = once;\n    this._thisArg = thisArg;\n    this._next = this._prev = this._owner = null;\n  }\n  SignalBinding.prototype.detach = function () {\n    if (this._owner === null) {\n      return false;\n    }\n    this._owner.detach(this);\n    return true;\n  };\n  return SignalBinding;\n}();\n/**\n * @private\n */\n/*!\n * @pixi/loaders - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/loaders is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nfunction _addSignalBinding(self, node) {\n  if (!self._head) {\n    self._head = node;\n    self._tail = node;\n  } else {\n    self._tail._next = node;\n    node._prev = self._tail;\n    self._tail = node;\n  }\n  node._owner = self;\n  return node;\n}\n/**\n * @memberof PIXI\n */\nvar Signal = /** @class */function () {\n  /**\n   * MiniSignal constructor.\n   * @example\n   * let mySignal = new Signal();\n   * let binding = mySignal.add(onSignal);\n   * mySignal.dispatch('foo', 'bar');\n   * mySignal.detach(binding);\n   */\n  function Signal() {\n    this._head = this._tail = undefined;\n  }\n  /**\n   * Return an array of attached SignalBinding.\n   *\n   * @param {Boolean} [exists=false] - We only need to know if there are handlers.\n   * @returns {PIXI.SignalBinding[]|Boolean} Array of attached SignalBinding or Boolean if called with exists = true\n   * @api public\n   */\n  Signal.prototype.handlers = function (exists) {\n    if (exists === void 0) {\n      exists = false;\n    }\n    var node = this._head;\n    if (exists) {\n      return !!node;\n    }\n    var ee = [];\n    while (node) {\n      ee.push(node);\n      node = node._next;\n    }\n    return ee;\n  };\n  /**\n   * Return true if node is a SignalBinding attached to this MiniSignal\n   *\n   * @param {PIXI.SignalBinding} node - Node to check.\n   * @returns {Boolean} True if node is attache to mini-signal\n   */\n  Signal.prototype.has = function (node) {\n    if (!(node instanceof SignalBinding)) {\n      throw new Error('MiniSignal#has(): First arg must be a SignalBinding object.');\n    }\n    return node._owner === this;\n  };\n  /**\n   * Dispaches a signal to all registered listeners.\n   *\n   * @returns {Boolean} Indication if we've emitted an event.\n   */\n  Signal.prototype.dispatch = function () {\n    var arguments$1 = arguments;\n\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments$1[_i];\n    }\n    var node = this._head;\n    if (!node) {\n      return false;\n    }\n    while (node) {\n      if (node._once) {\n        this.detach(node);\n      }\n      node._fn.apply(node._thisArg, args);\n      node = node._next;\n    }\n    return true;\n  };\n  /**\n   * Register a new listener.\n   *\n   * @param {Function} fn - Callback function.\n   * @param {object} [thisArg] - The context of the callback function.\n   * @returns {PIXI.SignalBinding} The SignalBinding node that was added.\n   */\n  Signal.prototype.add = function (fn, thisArg) {\n    if (thisArg === void 0) {\n      thisArg = null;\n    }\n    if (typeof fn !== 'function') {\n      throw new Error('MiniSignal#add(): First arg must be a Function.');\n    }\n    return _addSignalBinding(this, new SignalBinding(fn, false, thisArg));\n  };\n  /**\n   * Register a new listener that will be executed only once.\n   *\n   * @param {Function} fn - Callback function.\n   * @param {object} [thisArg] - The context of the callback function.\n   * @returns {PIXI.SignalBinding} The SignalBinding node that was added.\n   */\n  Signal.prototype.once = function (fn, thisArg) {\n    if (thisArg === void 0) {\n      thisArg = null;\n    }\n    if (typeof fn !== 'function') {\n      throw new Error('MiniSignal#once(): First arg must be a Function.');\n    }\n    return _addSignalBinding(this, new SignalBinding(fn, true, thisArg));\n  };\n  /**\n   * Remove binding object.\n   *\n   * @param {PIXI.SignalBinding} node - The binding node that will be removed.\n   * @returns {Signal} The instance on which this method was called.\n   * @api public */\n  Signal.prototype.detach = function (node) {\n    if (!(node instanceof SignalBinding)) {\n      throw new Error('MiniSignal#detach(): First arg must be a SignalBinding object.');\n    }\n    if (node._owner !== this) {\n      return this;\n    } // todo: or error?\n    if (node._prev) {\n      node._prev._next = node._next;\n    }\n    if (node._next) {\n      node._next._prev = node._prev;\n    }\n    if (node === this._head) {\n      // first node\n      this._head = node._next;\n      if (node._next === null) {\n        this._tail = null;\n      }\n    } else if (node === this._tail) {\n      // last node\n      this._tail = node._prev;\n      this._tail._next = null;\n    }\n    node._owner = null;\n    return this;\n  };\n  /**\n   * Detach all listeners.\n   *\n   * @returns {Signal} The instance on which this method was called.\n   */\n  Signal.prototype.detachAll = function () {\n    var node = this._head;\n    if (!node) {\n      return this;\n    }\n    this._head = this._tail = null;\n    while (node) {\n      node._owner = null;\n      node = node._next;\n    }\n    return this;\n  };\n  return Signal;\n}();\n\n/**\n * function from npm package `parseUri`, converted to TS to avoid leftpad incident\n * @param {string} str\n * @param [opts] - options\n * @param {boolean} [opts.strictMode] - type of parser\n */\nfunction parseUri(str, opts) {\n  opts = opts || {};\n  var o = {\n    // eslint-disable-next-line max-len\n    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\n    q: {\n      name: 'queryKey',\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      // eslint-disable-next-line max-len\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      // eslint-disable-next-line max-len\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  };\n  var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str);\n  var uri = {};\n  var i = 14;\n  while (i--) {\n    uri[o.key[i]] = m[i] || '';\n  }\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function (_t0, t1, t2) {\n    if (t1) {\n      uri[o.q.name][t1] = t2;\n    }\n  });\n  return uri;\n}\n\n// tests if CORS is supported in XHR, if not we need to use XDR\nvar useXdr;\nvar tempAnchor = null;\n// some status constants\nvar STATUS_NONE = 0;\nvar STATUS_OK = 200;\nvar STATUS_EMPTY = 204;\nvar STATUS_IE_BUG_EMPTY = 1223;\nvar STATUS_TYPE_OK = 2;\n// noop\nfunction _noop$1() {}\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n *\n * @ignore\n * @param map - The map to set on.\n * @param extname - The extension (or key) to set.\n * @param val - The value to set.\n */\nfunction setExtMap(map, extname, val) {\n  if (extname && extname.indexOf('.') === 0) {\n    extname = extname.substring(1);\n  }\n  if (!extname) {\n    return;\n  }\n  map[extname] = val;\n}\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param xhr - The request to check.\n * @return The type.\n */\nfunction reqType(xhr) {\n  return xhr.toString().replace('object ', '');\n}\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * Can be extended in `GlobalMixins.LoaderResource`.\n *\n * @memberof PIXI\n */\nvar LoaderResource = /** @class */function () {\n  /**\n   * @param {string} name - The name of the resource to load.\n   * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n   *      an array of sources.\n   * @param {object} [options] - The options for the load.\n   * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n   *      determine automatically.\n   * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n   *      longer than this time it is cancelled and the load is considered a failure. If this value is\n   *      set to `0` then there is no explicit timeout.\n   * @param {PIXI.LoaderResource.LOAD_TYPE} [options.loadType=LOAD_TYPE.XHR] - How should this resource\n   *      be loaded?\n   * @param {PIXI.LoaderResource.XHR_RESPONSE_TYPE} [options.xhrType=XHR_RESPONSE_TYPE.DEFAULT] - How\n   *      should the data being loaded be interpreted when using XHR?\n   * @param {PIXI.LoaderResource.IMetadata} [options.metadata] - Extra configuration for middleware\n   *      and the Resource object.\n   */\n  function LoaderResource(name, url, options) {\n    /**\n     * The `dequeue` method that will be used a storage place for the async queue dequeue method\n     * used privately by the loader.\n     *\n     * @private\n     * @member {function}\n     */\n    this._dequeue = _noop$1;\n    /**\n     * Used a storage place for the on load binding used privately by the loader.\n     *\n     * @private\n     * @member {function}\n     */\n    this._onLoadBinding = null;\n    /**\n     * The timer for element loads to check if they timeout.\n     *\n     * @private\n     */\n    this._elementTimer = 0;\n    /**\n     * The `complete` function bound to this resource's context.\n     *\n     * @private\n     * @type {function}\n     */\n    this._boundComplete = null;\n    /**\n     * The `_onError` function bound to this resource's context.\n     *\n     * @private\n     * @type {function}\n     */\n    this._boundOnError = null;\n    /**\n     * The `_onProgress` function bound to this resource's context.\n     *\n     * @private\n     * @type {function}\n     */\n    this._boundOnProgress = null;\n    /**\n     * The `_onTimeout` function bound to this resource's context.\n     *\n     * @private\n     * @type {function}\n     */\n    this._boundOnTimeout = null;\n    this._boundXhrOnError = null;\n    this._boundXhrOnTimeout = null;\n    this._boundXhrOnAbort = null;\n    this._boundXhrOnLoad = null;\n    if (typeof name !== 'string' || typeof url !== 'string') {\n      throw new Error('Both name and url are required for constructing a resource.');\n    }\n    options = options || {};\n    this._flags = 0;\n    // set data url flag, needs to be set early for some _determineX checks to work.\n    this._setFlag(LoaderResource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n    this.name = name;\n    this.url = url;\n    this.extension = this._getExtension();\n    this.data = null;\n    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n    this.timeout = options.timeout || 0;\n    this.loadType = options.loadType || this._determineLoadType();\n    // The type used to load the resource via XHR. If unset, determined automatically.\n    this.xhrType = options.xhrType;\n    // Extra info for middleware, and controlling specifics about how the resource loads.\n    // Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n    // Meaning it will modify it as it sees fit.\n    this.metadata = options.metadata || {};\n    // The error that occurred while loading (if any).\n    this.error = null;\n    // The XHR object that was used to load this resource. This is only set\n    // when `loadType` is `LoaderResource.LOAD_TYPE.XHR`.\n    this.xhr = null;\n    // The child resources this resource owns.\n    this.children = [];\n    // The resource type.\n    this.type = LoaderResource.TYPE.UNKNOWN;\n    // The progress chunk owned by this resource.\n    this.progressChunk = 0;\n    // The `dequeue` method that will be used a storage place for the async queue dequeue method\n    // used privately by the loader.\n    this._dequeue = _noop$1;\n    // Used a storage place for the on load binding used privately by the loader.\n    this._onLoadBinding = null;\n    // The timer for element loads to check if they timeout.\n    this._elementTimer = 0;\n    this._boundComplete = this.complete.bind(this);\n    this._boundOnError = this._onError.bind(this);\n    this._boundOnProgress = this._onProgress.bind(this);\n    this._boundOnTimeout = this._onTimeout.bind(this);\n    // xhr callbacks\n    this._boundXhrOnError = this._xhrOnError.bind(this);\n    this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n    // Dispatched when the resource beings to load.\n    this.onStart = new Signal();\n    // Dispatched each time progress of this resource load updates.\n    // Not all resources types and loader systems can support this event\n    // so sometimes it may not be available. If the resource\n    // is being loaded on a modern browser, using XHR, and the remote server\n    // properly sets Content-Length headers, then this will be available.\n    this.onProgress = new Signal();\n    // Dispatched once this resource has loaded, if there was an error it will\n    // be in the `error` property.\n    this.onComplete = new Signal();\n    // Dispatched after this resource has had all the *after* middleware run on it.\n    this.onAfterMiddleware = new Signal();\n  }\n  /**\n   * Sets the load type to be used for a specific extension.\n   *\n   * @static\n   * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n   * @param {PIXI.LoaderResource.LOAD_TYPE} loadType - The load type to set it to.\n   */\n  LoaderResource.setExtensionLoadType = function (extname, loadType) {\n    setExtMap(LoaderResource._loadTypeMap, extname, loadType);\n  };\n  /**\n   * Sets the load type to be used for a specific extension.\n   *\n   * @static\n   * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n   * @param {PIXI.LoaderResource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n   */\n  LoaderResource.setExtensionXhrType = function (extname, xhrType) {\n    setExtMap(LoaderResource._xhrTypeMap, extname, xhrType);\n  };\n  Object.defineProperty(LoaderResource.prototype, \"isDataUrl\", {\n    /**\n     * When the resource starts to load.\n     *\n     * @memberof PIXI.LoaderResource\n     * @callback OnStartSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n    /**\n     * When the resource reports loading progress.\n     *\n     * @memberof PIXI.LoaderResource\n     * @callback OnProgressSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     * @param {number} percentage - The progress of the load in the range [0, 1].\n     */\n    /**\n     * When the resource finishes loading.\n     *\n     * @memberof PIXI.LoaderResource\n     * @callback OnCompleteSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n    /**\n     * @memberof PIXI.LoaderResource\n     * @typedef {object} IMetadata\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @property {string|string[]} [mimeType] - The mime type to use for the source element\n     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n     *      where each index is the mime type to use for the corresponding url index.\n     */\n    /**\n     * Stores whether or not this url is a data url.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get: function () {\n      return this._hasFlag(LoaderResource.STATUS_FLAGS.DATA_URL);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LoaderResource.prototype, \"isComplete\", {\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get: function () {\n      return this._hasFlag(LoaderResource.STATUS_FLAGS.COMPLETE);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LoaderResource.prototype, \"isLoading\", {\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get: function () {\n      return this._hasFlag(LoaderResource.STATUS_FLAGS.LOADING);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Marks the resource as complete.\n   *\n   */\n  LoaderResource.prototype.complete = function () {\n    this._clearEvents();\n    this._finish();\n  };\n  /**\n   * Aborts the loading of this resource, with an optional message.\n   *\n   * @param {string} message - The message to use for the error\n   */\n  LoaderResource.prototype.abort = function (message) {\n    // abort can be called multiple times, ignore subsequent calls.\n    if (this.error) {\n      return;\n    }\n    // store error\n    this.error = new Error(message);\n    // clear events before calling aborts\n    this._clearEvents();\n    // abort the actual loading\n    if (this.xhr) {\n      this.xhr.abort();\n    } else if (this.xdr) {\n      this.xdr.abort();\n    } else if (this.data) {\n      // single source\n      if (this.data.src) {\n        this.data.src = LoaderResource.EMPTY_GIF;\n      }\n      // multi-source\n      else {\n          while (this.data.firstChild) {\n            this.data.removeChild(this.data.firstChild);\n          }\n        }\n    }\n    // done now.\n    this._finish();\n  };\n  /**\n   * Kicks off loading of this resource. This method is asynchronous.\n   *\n   * @param {PIXI.LoaderResource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n   */\n  LoaderResource.prototype.load = function (cb) {\n    var _this = this;\n    if (this.isLoading) {\n      return;\n    }\n    if (this.isComplete) {\n      if (cb) {\n        setTimeout(function () {\n          return cb(_this);\n        }, 1);\n      }\n      return;\n    } else if (cb) {\n      this.onComplete.once(cb);\n    }\n    this._setFlag(LoaderResource.STATUS_FLAGS.LOADING, true);\n    this.onStart.dispatch(this);\n    // if unset, determine the value\n    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n      this.crossOrigin = this._determineCrossOrigin(this.url);\n    }\n    switch (this.loadType) {\n      case LoaderResource.LOAD_TYPE.IMAGE:\n        this.type = LoaderResource.TYPE.IMAGE;\n        this._loadElement('image');\n        break;\n      case LoaderResource.LOAD_TYPE.AUDIO:\n        this.type = LoaderResource.TYPE.AUDIO;\n        this._loadSourceElement('audio');\n        break;\n      case LoaderResource.LOAD_TYPE.VIDEO:\n        this.type = LoaderResource.TYPE.VIDEO;\n        this._loadSourceElement('video');\n        break;\n      case LoaderResource.LOAD_TYPE.XHR:\n      /* falls through */\n      default:\n        if (typeof useXdr === 'undefined') {\n          useXdr = !!(globalThis.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));\n        }\n        if (useXdr && this.crossOrigin) {\n          this._loadXdr();\n        } else {\n          this._loadXhr();\n        }\n        break;\n    }\n  };\n  /**\n   * Checks if the flag is set.\n   *\n   * @param flag - The flag to check.\n   * @return True if the flag is set.\n   */\n  LoaderResource.prototype._hasFlag = function (flag) {\n    return (this._flags & flag) !== 0;\n  };\n  /**\n   * (Un)Sets the flag.\n   *\n   * @param flag - The flag to (un)set.\n   * @param value - Whether to set or (un)set the flag.\n   */\n  LoaderResource.prototype._setFlag = function (flag, value) {\n    this._flags = value ? this._flags | flag : this._flags & ~flag;\n  };\n  /**\n   * Clears all the events from the underlying loading source.\n   */\n  LoaderResource.prototype._clearEvents = function () {\n    clearTimeout(this._elementTimer);\n    if (this.data && this.data.removeEventListener) {\n      this.data.removeEventListener('error', this._boundOnError, false);\n      this.data.removeEventListener('load', this._boundComplete, false);\n      this.data.removeEventListener('progress', this._boundOnProgress, false);\n      this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n    }\n    if (this.xhr) {\n      if (this.xhr.removeEventListener) {\n        this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n        this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n        this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n        this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n        this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n      } else {\n        this.xhr.onerror = null;\n        this.xhr.ontimeout = null;\n        this.xhr.onprogress = null;\n        this.xhr.onload = null;\n      }\n    }\n  };\n  /**\n   * Finalizes the load.\n   */\n  LoaderResource.prototype._finish = function () {\n    if (this.isComplete) {\n      throw new Error('Complete called again for an already completed resource.');\n    }\n    this._setFlag(LoaderResource.STATUS_FLAGS.COMPLETE, true);\n    this._setFlag(LoaderResource.STATUS_FLAGS.LOADING, false);\n    this.onComplete.dispatch(this);\n  };\n  /**\n   * Loads this resources using an element that has a single source,\n   * like an HTMLImageElement.\n   * @private\n   * @param type - The type of element to use.\n   */\n  LoaderResource.prototype._loadElement = function (type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === 'image' && typeof globalThis.Image !== 'undefined') {\n      this.data = new Image();\n    } else {\n      this.data = document.createElement(type);\n    }\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n    if (!this.metadata.skipSource) {\n      this.data.src = this.url;\n    }\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  };\n  /**\n   * Loads this resources using an element that has multiple sources,\n   * like an HTMLAudioElement or HTMLVideoElement.\n   * @param type - The type of element to use.\n   */\n  LoaderResource.prototype._loadSourceElement = function (type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === 'audio' && typeof globalThis.Audio !== 'undefined') {\n      this.data = new Audio();\n    } else {\n      this.data = document.createElement(type);\n    }\n    if (this.data === null) {\n      this.abort(\"Unsupported element: \" + type);\n      return;\n    }\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n    if (!this.metadata.skipSource) {\n      // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n      if (navigator.isCocoonJS) {\n        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n      } else if (Array.isArray(this.url)) {\n        var mimeTypes = this.metadata.mimeType;\n        for (var i = 0; i < this.url.length; ++i) {\n          this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));\n        }\n      } else {\n        var mimeTypes = this.metadata.mimeType;\n        this.data.appendChild(this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes));\n      }\n    }\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    this.data.addEventListener('canplaythrough', this._boundComplete, false);\n    this.data.load();\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  };\n  /**\n   * Loads this resources using an XMLHttpRequest.\n   */\n  LoaderResource.prototype._loadXhr = function () {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n      this.xhrType = this._determineXhrType();\n    }\n    var xhr = this.xhr = new XMLHttpRequest();\n    // send credentials when crossOrigin with credentials requested\n    if (this.crossOrigin === 'use-credentials') {\n      xhr.withCredentials = true;\n    }\n    // set the request type and url\n    xhr.open('GET', this.url, true);\n    xhr.timeout = this.timeout;\n    // load json as text and parse it ourselves. We do this because some browsers\n    // *cough* safari *cough* can't deal with it.\n    if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.JSON || this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT) {\n      xhr.responseType = LoaderResource.XHR_RESPONSE_TYPE.TEXT;\n    } else {\n      xhr.responseType = this.xhrType;\n    }\n    xhr.addEventListener('error', this._boundXhrOnError, false);\n    xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n    xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n    xhr.addEventListener('progress', this._boundOnProgress, false);\n    xhr.addEventListener('load', this._boundXhrOnLoad, false);\n    xhr.send();\n  };\n  /**\n   * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n   */\n  LoaderResource.prototype._loadXdr = function () {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n      this.xhrType = this._determineXhrType();\n    }\n    var xdr = this.xhr = new globalThis.XDomainRequest(); // eslint-disable-line no-undef\n    // XDomainRequest has a few quirks. Occasionally it will abort requests\n    // A way to avoid this is to make sure ALL callbacks are set even if not used\n    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n    xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n    xdr.onerror = this._boundXhrOnError;\n    xdr.ontimeout = this._boundXhrOnTimeout;\n    xdr.onprogress = this._boundOnProgress;\n    xdr.onload = this._boundXhrOnLoad;\n    xdr.open('GET', this.url, true);\n    // Note: The xdr.send() call is wrapped in a timeout to prevent an\n    // issue with the interface where some requests are lost if multiple\n    // XDomainRequests are being sent at the same time.\n    // Some info here: https://github.com/photonstorm/phaser/issues/1248\n    setTimeout(function () {\n      return xdr.send();\n    }, 1);\n  };\n  /**\n   * Creates a source used in loading via an element.\n   * @param type - The element type (video or audio).\n   * @param url - The source URL to load from.\n   * @param [mime] - The mime type of the video\n   * @return The source element.\n   */\n  LoaderResource.prototype._createSource = function (type, url, mime) {\n    if (!mime) {\n      mime = type + \"/\" + this._getExtension(url);\n    }\n    var source = document.createElement('source');\n    source.src = url;\n    source.type = mime;\n    return source;\n  };\n  /**\n   * Called if a load errors out.\n   *\n   * @param event - The error event from the element that emits it.\n   */\n  LoaderResource.prototype._onError = function (event) {\n    this.abort(\"Failed to load element using: \" + event.target.nodeName);\n  };\n  /**\n   * Called if a load progress event fires for an element or xhr/xdr.\n   * @param event - Progress event.\n   */\n  LoaderResource.prototype._onProgress = function (event) {\n    if (event && event.lengthComputable) {\n      this.onProgress.dispatch(this, event.loaded / event.total);\n    }\n  };\n  /**\n   * Called if a timeout event fires for an element.\n   */\n  LoaderResource.prototype._onTimeout = function () {\n    this.abort(\"Load timed out.\");\n  };\n  /**\n   * Called if an error event fires for xhr/xdr.\n   */\n  LoaderResource.prototype._xhrOnError = function () {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request failed. Status: \" + xhr.status + \", text: \\\"\" + xhr.statusText + \"\\\"\");\n  };\n  /**\n   * Called if an error event fires for xhr/xdr.\n   */\n  LoaderResource.prototype._xhrOnTimeout = function () {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request timed out.\");\n  };\n  /**\n   * Called if an abort event fires for xhr/xdr.\n   */\n  LoaderResource.prototype._xhrOnAbort = function () {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request was aborted by the user.\");\n  };\n  /**\n   * Called when data successfully loads from an xhr/xdr request.\n   */\n  LoaderResource.prototype._xhrOnLoad = function () {\n    var xhr = this.xhr;\n    var text = '';\n    var status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n    // responseText is accessible only if responseType is '' or 'text' and on older browsers\n    if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n      text = xhr.responseText;\n    }\n    // status can be 0 when using the `file://` protocol so we also check if a response is set.\n    // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n    if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === LoaderResource.XHR_RESPONSE_TYPE.BUFFER)) {\n      status = STATUS_OK;\n    }\n    // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n    else if (status === STATUS_IE_BUG_EMPTY) {\n        status = STATUS_EMPTY;\n      }\n    var statusType = status / 100 | 0;\n    if (statusType === STATUS_TYPE_OK) {\n      // if text, just return it\n      if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.TEXT) {\n        this.data = text;\n        this.type = LoaderResource.TYPE.TEXT;\n      }\n      // if json, parse into json object\n      else if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.JSON) {\n          try {\n            this.data = JSON.parse(text);\n            this.type = LoaderResource.TYPE.JSON;\n          } catch (e) {\n            this.abort(\"Error trying to parse loaded json: \" + e);\n            return;\n          }\n        }\n        // if xml, parse into an xml document or div element\n        else if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT) {\n            try {\n              if (globalThis.DOMParser) {\n                var domparser = new DOMParser();\n                this.data = domparser.parseFromString(text, 'text/xml');\n              } else {\n                var div = document.createElement('div');\n                div.innerHTML = text;\n                this.data = div;\n              }\n              this.type = LoaderResource.TYPE.XML;\n            } catch (e$1) {\n              this.abort(\"Error trying to parse loaded xml: \" + e$1);\n              return;\n            }\n          }\n          // other types just return the response\n          else {\n              this.data = xhr.response || text;\n            }\n    } else {\n      this.abort(\"[\" + xhr.status + \"] \" + xhr.statusText + \": \" + xhr.responseURL);\n      return;\n    }\n    this.complete();\n  };\n  /**\n   * Sets the `crossOrigin` property for this resource based on if the url\n   * for this resource is cross-origin. If crossOrigin was manually set, this\n   * function does nothing.\n   * @private\n   * @param url - The url to test.\n   * @param [loc=globalThis.location] - The location object to test against.\n   * @return The crossOrigin value to use (or empty string for none).\n   */\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  LoaderResource.prototype._determineCrossOrigin = function (url, loc) {\n    // data: and javascript: urls are considered same-origin\n    if (url.indexOf('data:') === 0) {\n      return '';\n    }\n    // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n    // origin designed not to match globalThis.location.origin, and will always require\n    // crossOrigin requests regardless of whether the location matches.\n    if (globalThis.origin !== globalThis.location.origin) {\n      return 'anonymous';\n    }\n    // default is globalThis.location\n    loc = loc || globalThis.location;\n    if (!tempAnchor) {\n      tempAnchor = document.createElement('a');\n    }\n    // let the browser determine the full href for the url of this resource and then\n    // parse with the node url lib, we can't use the properties of the anchor element\n    // because they don't work in IE9 :(\n    tempAnchor.href = url;\n    var parsedUrl = parseUri(tempAnchor.href, { strictMode: true });\n    var samePort = !parsedUrl.port && loc.port === '' || parsedUrl.port === loc.port;\n    var protocol = parsedUrl.protocol ? parsedUrl.protocol + \":\" : '';\n    // if cross origin\n    if (parsedUrl.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n      return 'anonymous';\n    }\n    return '';\n  };\n  /**\n   * Determines the responseType of an XHR request based on the extension of the\n   * resource being loaded.\n   *\n   * @private\n   * @return {PIXI.LoaderResource.XHR_RESPONSE_TYPE} The responseType to use.\n   */\n  LoaderResource.prototype._determineXhrType = function () {\n    return LoaderResource._xhrTypeMap[this.extension] || LoaderResource.XHR_RESPONSE_TYPE.TEXT;\n  };\n  /**\n   * Determines the loadType of a resource based on the extension of the\n   * resource being loaded.\n   *\n   * @private\n   * @return {PIXI.LoaderResource.LOAD_TYPE} The loadType to use.\n   */\n  LoaderResource.prototype._determineLoadType = function () {\n    return LoaderResource._loadTypeMap[this.extension] || LoaderResource.LOAD_TYPE.XHR;\n  };\n  /**\n   * Extracts the extension (sans '.') of the file being loaded by the resource.\n   *\n   * @param [url] - url to parse, `this.url` by default.\n   * @return The extension.\n   */\n  LoaderResource.prototype._getExtension = function (url) {\n    if (url === void 0) {\n      url = this.url;\n    }\n    var ext = '';\n    if (this.isDataUrl) {\n      var slashIndex = url.indexOf('/');\n      ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n    } else {\n      var queryStart = url.indexOf('?');\n      var hashStart = url.indexOf('#');\n      var index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);\n      url = url.substring(0, index);\n      ext = url.substring(url.lastIndexOf('.') + 1);\n    }\n    return ext.toLowerCase();\n  };\n  /**\n   * Determines the mime type of an XHR request based on the responseType of\n   * resource being loaded.\n   *\n   * @param type - The type to get a mime type for.\n   * @private\n   * @return The mime type to use.\n   */\n  LoaderResource.prototype._getMimeFromXhrType = function (type) {\n    switch (type) {\n      case LoaderResource.XHR_RESPONSE_TYPE.BUFFER:\n        return 'application/octet-binary';\n      case LoaderResource.XHR_RESPONSE_TYPE.BLOB:\n        return 'application/blob';\n      case LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT:\n        return 'application/xml';\n      case LoaderResource.XHR_RESPONSE_TYPE.JSON:\n        return 'application/json';\n      case LoaderResource.XHR_RESPONSE_TYPE.DEFAULT:\n      case LoaderResource.XHR_RESPONSE_TYPE.TEXT:\n      /* falls through */\n      default:\n        return 'text/plain';\n    }\n  };\n  return LoaderResource;\n}();\n// eslint-disable-next-line @typescript-eslint/no-namespace\n(function (LoaderResource) {\n  (function (STATUS_FLAGS) {\n    /** None */\n    STATUS_FLAGS[STATUS_FLAGS[\"NONE\"] = 0] = \"NONE\";\n    /** Data URL */\n    STATUS_FLAGS[STATUS_FLAGS[\"DATA_URL\"] = 1] = \"DATA_URL\";\n    /** Complete */\n    STATUS_FLAGS[STATUS_FLAGS[\"COMPLETE\"] = 2] = \"COMPLETE\";\n    /** Loading */\n    STATUS_FLAGS[STATUS_FLAGS[\"LOADING\"] = 4] = \"LOADING\";\n  })(LoaderResource.STATUS_FLAGS || (LoaderResource.STATUS_FLAGS = {}));\n  (function (TYPE) {\n    /** Unknown */\n    TYPE[TYPE[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /** JSON */\n    TYPE[TYPE[\"JSON\"] = 1] = \"JSON\";\n    /** XML */\n    TYPE[TYPE[\"XML\"] = 2] = \"XML\";\n    /** Image */\n    TYPE[TYPE[\"IMAGE\"] = 3] = \"IMAGE\";\n    /** Audio */\n    TYPE[TYPE[\"AUDIO\"] = 4] = \"AUDIO\";\n    /** Video */\n    TYPE[TYPE[\"VIDEO\"] = 5] = \"VIDEO\";\n    /** Plain text */\n    TYPE[TYPE[\"TEXT\"] = 6] = \"TEXT\";\n  })(LoaderResource.TYPE || (LoaderResource.TYPE = {}));\n  (function (LOAD_TYPE) {\n    /** Uses XMLHttpRequest to load the resource. */\n    LOAD_TYPE[LOAD_TYPE[\"XHR\"] = 1] = \"XHR\";\n    /** Uses an `Image` object to load the resource. */\n    LOAD_TYPE[LOAD_TYPE[\"IMAGE\"] = 2] = \"IMAGE\";\n    /** Uses an `Audio` object to load the resource. */\n    LOAD_TYPE[LOAD_TYPE[\"AUDIO\"] = 3] = \"AUDIO\";\n    /** Uses a `Video` object to load the resource. */\n    LOAD_TYPE[LOAD_TYPE[\"VIDEO\"] = 4] = \"VIDEO\";\n  })(LoaderResource.LOAD_TYPE || (LoaderResource.LOAD_TYPE = {}));\n  (function (XHR_RESPONSE_TYPE) {\n    /** string */\n    XHR_RESPONSE_TYPE[\"DEFAULT\"] = \"text\";\n    /** ArrayBuffer */\n    XHR_RESPONSE_TYPE[\"BUFFER\"] = \"arraybuffer\";\n    /** Blob */\n    XHR_RESPONSE_TYPE[\"BLOB\"] = \"blob\";\n    /** Document */\n    XHR_RESPONSE_TYPE[\"DOCUMENT\"] = \"document\";\n    /** Object */\n    XHR_RESPONSE_TYPE[\"JSON\"] = \"json\";\n    /** String */\n    XHR_RESPONSE_TYPE[\"TEXT\"] = \"text\";\n  })(LoaderResource.XHR_RESPONSE_TYPE || (LoaderResource.XHR_RESPONSE_TYPE = {}));\n  LoaderResource._loadTypeMap = {\n    // images\n    gif: LoaderResource.LOAD_TYPE.IMAGE,\n    png: LoaderResource.LOAD_TYPE.IMAGE,\n    bmp: LoaderResource.LOAD_TYPE.IMAGE,\n    jpg: LoaderResource.LOAD_TYPE.IMAGE,\n    jpeg: LoaderResource.LOAD_TYPE.IMAGE,\n    tif: LoaderResource.LOAD_TYPE.IMAGE,\n    tiff: LoaderResource.LOAD_TYPE.IMAGE,\n    webp: LoaderResource.LOAD_TYPE.IMAGE,\n    tga: LoaderResource.LOAD_TYPE.IMAGE,\n    svg: LoaderResource.LOAD_TYPE.IMAGE,\n    'svg+xml': LoaderResource.LOAD_TYPE.IMAGE,\n    // audio\n    mp3: LoaderResource.LOAD_TYPE.AUDIO,\n    ogg: LoaderResource.LOAD_TYPE.AUDIO,\n    wav: LoaderResource.LOAD_TYPE.AUDIO,\n    // videos\n    mp4: LoaderResource.LOAD_TYPE.VIDEO,\n    webm: LoaderResource.LOAD_TYPE.VIDEO\n  };\n  LoaderResource._xhrTypeMap = {\n    // xml\n    xhtml: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    html: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n    // this should probably be fine.\n    tsx: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    // images\n    gif: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    png: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    bmp: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    jpg: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    jpeg: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    tif: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    tiff: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    webp: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    tga: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    // json\n    json: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n    // text\n    text: LoaderResource.XHR_RESPONSE_TYPE.TEXT,\n    txt: LoaderResource.XHR_RESPONSE_TYPE.TEXT,\n    // fonts\n    ttf: LoaderResource.XHR_RESPONSE_TYPE.BUFFER,\n    otf: LoaderResource.XHR_RESPONSE_TYPE.BUFFER\n  };\n  // We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\n  LoaderResource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n})(LoaderResource || (exports.LoaderResource = LoaderResource = {}));\n\n/**\n * Smaller version of the async library constructs.\n * @ignore\n */\nfunction _noop() {}\n/**\n * Ensures a function is only called once.\n * @ignore\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\nfunction onlyOnce(fn) {\n  return function onceWrapper() {\n    var arguments$1 = arguments;\n\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments$1[_i];\n    }\n    if (fn === null) {\n      throw new Error('Callback was already called.');\n    }\n    var callFn = fn;\n    fn = null;\n    callFn.apply(this, args);\n  };\n}\n/**\n * @private\n * @memberof PIXI\n */\nvar AsyncQueueItem = /** @class */function () {\n  /**\n   * @private\n   */\n  function AsyncQueueItem(data, callback) {\n    this.data = data;\n    this.callback = callback;\n  }\n  return AsyncQueueItem;\n}();\n/**\n * @private\n * @memberof PIXI\n */\nvar AsyncQueue = /** @class */function () {\n  /**\n   * @private\n   */\n  function AsyncQueue(worker, concurrency) {\n    var _this = this;\n    if (concurrency === void 0) {\n      concurrency = 1;\n    }\n    this.workers = 0;\n    this.saturated = _noop;\n    this.unsaturated = _noop;\n    this.empty = _noop;\n    this.drain = _noop;\n    this.error = _noop;\n    this.started = false;\n    this.paused = false;\n    this._tasks = [];\n    this._insert = function (data, insertAtFront, callback) {\n      if (callback && typeof callback !== 'function') {\n        throw new Error('task callback must be a function');\n      }\n      _this.started = true;\n      // eslint-disable-next-line no-eq-null,eqeqeq\n      if (data == null && _this.idle()) {\n        // call drain immediately if there are no tasks\n        setTimeout(function () {\n          return _this.drain();\n        }, 1);\n        return;\n      }\n      var item = new AsyncQueueItem(data, typeof callback === 'function' ? callback : _noop);\n      if (insertAtFront) {\n        _this._tasks.unshift(item);\n      } else {\n        _this._tasks.push(item);\n      }\n      setTimeout(_this.process, 1);\n    };\n    this.process = function () {\n      while (!_this.paused && _this.workers < _this.concurrency && _this._tasks.length) {\n        var task = _this._tasks.shift();\n        if (_this._tasks.length === 0) {\n          _this.empty();\n        }\n        _this.workers += 1;\n        if (_this.workers === _this.concurrency) {\n          _this.saturated();\n        }\n        _this._worker(task.data, onlyOnce(_this._next(task)));\n      }\n    };\n    this._worker = worker;\n    if (concurrency === 0) {\n      throw new Error('Concurrency must not be zero');\n    }\n    this.concurrency = concurrency;\n    this.buffer = concurrency / 4.0;\n  }\n  /**\n   * @private\n   */\n  AsyncQueue.prototype._next = function (task) {\n    var _this = this;\n    return function () {\n      var arguments$1 = arguments;\n\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments$1[_i];\n      }\n      _this.workers -= 1;\n      task.callback.apply(task, args);\n      // eslint-disable-next-line no-eq-null,eqeqeq\n      if (args[0] != null) {\n        _this.error(args[0], task.data);\n      }\n      if (_this.workers <= _this.concurrency - _this.buffer) {\n        _this.unsaturated();\n      }\n      if (_this.idle()) {\n        _this.drain();\n      }\n      _this.process();\n    };\n  };\n  // That was in object\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  AsyncQueue.prototype.push = function (data, callback) {\n    this._insert(data, false, callback);\n  };\n  AsyncQueue.prototype.kill = function () {\n    this.workers = 0;\n    this.drain = _noop;\n    this.started = false;\n    this._tasks = [];\n  };\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  AsyncQueue.prototype.unshift = function (data, callback) {\n    this._insert(data, true, callback);\n  };\n  AsyncQueue.prototype.length = function () {\n    return this._tasks.length;\n  };\n  AsyncQueue.prototype.running = function () {\n    return this.workers;\n  };\n  AsyncQueue.prototype.idle = function () {\n    return this._tasks.length + this.workers === 0;\n  };\n  AsyncQueue.prototype.pause = function () {\n    if (this.paused === true) {\n      return;\n    }\n    this.paused = true;\n  };\n  AsyncQueue.prototype.resume = function () {\n    if (this.paused === false) {\n      return;\n    }\n    this.paused = false;\n    // Need to call this.process once per concurrent\n    // worker to preserve full concurrency after pause\n    for (var w = 1; w <= this.concurrency; w++) {\n      this.process();\n    }\n  };\n  /**\n   * Iterates an array in series.\n   *\n   * @param {Array.<*>} array - Array to iterate.\n   * @param {function} iterator - Function to call for each element.\n   * @param {function} callback - Function to call when done, or on error.\n   * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n   */\n  AsyncQueue.eachSeries = function (array, iterator, callback, deferNext) {\n    var i = 0;\n    var len = array.length;\n    function next(err) {\n      if (err || i === len) {\n        if (callback) {\n          callback(err);\n        }\n        return;\n      }\n      if (deferNext) {\n        setTimeout(function () {\n          iterator(array[i++], next);\n        }, 1);\n      } else {\n        iterator(array[i++], next);\n      }\n    }\n    next();\n  };\n  /**\n   * Async queue implementation,\n   *\n   * @param {function} worker - The worker function to call for each task.\n   * @param {number} concurrency - How many workers to run in parrallel.\n   * @return {*} The async queue object.\n   */\n  AsyncQueue.queue = function (worker, concurrency) {\n    return new AsyncQueue(worker, concurrency);\n  };\n  return AsyncQueue;\n}();\n\n// some constants\nvar MAX_PROGRESS = 100;\nvar rgxExtractUrlHash = /(#[\\w-]+)?$/;\n/**\n * The new loader, forked from Resource Loader by Chad Engler: https://github.com/englercj/resource-loader\n *\n * ```js\n * const loader = PIXI.Loader.shared; // PixiJS exposes a premade instance for you to use.\n * // or\n * const loader = new PIXI.Loader(); // You can also create your own if you want\n *\n * const sprites = {};\n *\n * // Chainable `add` to enqueue a resource\n * loader.add('bunny', 'data/bunny.png')\n *       .add('spaceship', 'assets/spritesheet.json');\n * loader.add('scoreFont', 'assets/score.fnt');\n *\n * // Chainable `pre` to add a middleware that runs for each resource, *before* loading that resource.\n * // This is useful to implement custom caching modules (using filesystem, indexeddb, memory, etc).\n * loader.pre(cachingMiddleware);\n *\n * // Chainable `use` to add a middleware that runs for each resource, *after* loading that resource.\n * // This is useful to implement custom parsing modules (like spritesheet parsers, spine parser, etc).\n * loader.use(parsingMiddleware);\n *\n * // The `load` method loads the queue of resources, and calls the passed in callback called once all\n * // resources have loaded.\n * loader.load((loader, resources) => {\n *     // resources is an object where the key is the name of the resource loaded and the value is the resource object.\n *     // They have a couple default properties:\n *     // - `url`: The URL that the resource was loaded from\n *     // - `error`: The error that happened when trying to load (if any)\n *     // - `data`: The raw data that was loaded\n *     // also may contain other properties based on the middleware that runs.\n *     sprites.bunny = new PIXI.TilingSprite(resources.bunny.texture);\n *     sprites.spaceship = new PIXI.TilingSprite(resources.spaceship.texture);\n *     sprites.scoreFont = new PIXI.TilingSprite(resources.scoreFont.texture);\n * });\n *\n * // throughout the process multiple signals can be dispatched.\n * loader.onProgress.add(() => {}); // called once per loaded/errored file\n * loader.onError.add(() => {}); // called once per errored file\n * loader.onLoad.add(() => {}); // called once per loaded file\n * loader.onComplete.add(() => {}); // called once when the queued resources all load.\n * ```\n *\n * @memberof PIXI\n */\nvar Loader = /** @class */function () {\n  /**\n   * @param baseUrl - The base url for all resources loaded by this loader.\n   * @param concurrency - The number of resources to load concurrently.\n   */\n  function Loader(baseUrl, concurrency) {\n    var _this = this;\n    if (baseUrl === void 0) {\n      baseUrl = '';\n    }\n    if (concurrency === void 0) {\n      concurrency = 10;\n    }\n    /**\n     * The progress percent of the loader going through the queue.\n     */\n    this.progress = 0;\n    /**\n     * Loading state of the loader, true if it is currently loading resources.\n     */\n    this.loading = false;\n    /**\n     * A querystring to append to every URL added to the loader.\n     *\n     * This should be a valid query string *without* the question-mark (`?`). The loader will\n     * also *not* escape values for you. Make sure to escape your parameters with\n     * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n     *\n     * @example\n     * const loader = new Loader();\n     *\n     * loader.defaultQueryString = 'user=me&password=secret';\n     *\n     * // This will request 'image.png?user=me&password=secret'\n     * loader.add('image.png').load();\n     *\n     * loader.reset();\n     *\n     * // This will request 'image.png?v=1&user=me&password=secret'\n     * loader.add('iamge.png?v=1').load();\n     */\n    this.defaultQueryString = '';\n    /**\n     * The middleware to run before loading each resource.\n     */\n    this._beforeMiddleware = [];\n    /**\n     * The middleware to run after loading each resource.\n     */\n    this._afterMiddleware = [];\n    /**\n     * The tracks the resources we are currently completing parsing for.\n     */\n    this._resourcesParsing = [];\n    /**\n     * The `_loadResource` function bound with this object context.\n     *\n     * @param r - The resource to load\n     * @param d - The dequeue function\n     */\n    this._boundLoadResource = function (r, d) {\n      return _this._loadResource(r, d);\n    };\n    /**\n     * All the resources for this loader keyed by name.\n     */\n    this.resources = {};\n    this.baseUrl = baseUrl;\n    this._beforeMiddleware = [];\n    this._afterMiddleware = [];\n    this._resourcesParsing = [];\n    this._boundLoadResource = function (r, d) {\n      return _this._loadResource(r, d);\n    };\n    this._queue = AsyncQueue.queue(this._boundLoadResource, concurrency);\n    this._queue.pause();\n    this.resources = {};\n    this.onProgress = new Signal();\n    this.onError = new Signal();\n    this.onLoad = new Signal();\n    this.onStart = new Signal();\n    this.onComplete = new Signal();\n    for (var i = 0; i < Loader._plugins.length; ++i) {\n      var plugin = Loader._plugins[i];\n      var pre = plugin.pre,\n          use = plugin.use;\n      if (pre) {\n        this.pre(pre);\n      }\n      if (use) {\n        this.use(use);\n      }\n    }\n    this._protected = false;\n  }\n  /**\n   * Same as add, params have strict order\n   *\n   * @private\n   * @param name - The name of the resource to load.\n   * @param url - The url for this resource, relative to the baseUrl of this loader.\n   * @param options - The options for the load.\n   * @param callback - Function to call when this specific resource completes loading.\n   * @return The loader itself.\n   */\n  Loader.prototype._add = function (name, url, options, callback) {\n    // if loading already you can only add resources that have a parent.\n    if (this.loading && (!options || !options.parentResource)) {\n      throw new Error('Cannot add resources while the loader is running.');\n    }\n    // check if resource already exists.\n    if (this.resources[name]) {\n      throw new Error(\"Resource named \\\"\" + name + \"\\\" already exists.\");\n    }\n    // add base url if this isn't an absolute url\n    url = this._prepareUrl(url);\n    // create the store the resource\n    this.resources[name] = new LoaderResource(name, url, options);\n    if (typeof callback === 'function') {\n      this.resources[name].onAfterMiddleware.once(callback);\n    }\n    // if actively loading, make sure to adjust progress chunks for that parent and its children\n    if (this.loading) {\n      var parent = options.parentResource;\n      var incompleteChildren = [];\n      for (var i = 0; i < parent.children.length; ++i) {\n        if (!parent.children[i].isComplete) {\n          incompleteChildren.push(parent.children[i]);\n        }\n      }\n      var fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent\n      var eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child\n      parent.children.push(this.resources[name]);\n      parent.progressChunk = eachChunk;\n      for (var i = 0; i < incompleteChildren.length; ++i) {\n        incompleteChildren[i].progressChunk = eachChunk;\n      }\n      this.resources[name].progressChunk = eachChunk;\n    }\n    // add the resource to the queue\n    this._queue.push(this.resources[name]);\n    return this;\n  };\n  /* eslint-enable require-jsdoc,valid-jsdoc */\n  /**\n   * Sets up a middleware function that will run *before* the\n   * resource is loaded.\n   *\n   * @param fn - The middleware function to register.\n   * @return The loader itself.\n   */\n  Loader.prototype.pre = function (fn) {\n    this._beforeMiddleware.push(fn);\n    return this;\n  };\n  /**\n   * Sets up a middleware function that will run *after* the\n   * resource is loaded.\n   *\n   * @param fn - The middleware function to register.\n   * @return The loader itself.\n   */\n  Loader.prototype.use = function (fn) {\n    this._afterMiddleware.push(fn);\n    return this;\n  };\n  /**\n   * Resets the queue of the loader to prepare for a new load.\n   *\n   * @return The loader itself.\n   */\n  Loader.prototype.reset = function () {\n    this.progress = 0;\n    this.loading = false;\n    this._queue.kill();\n    this._queue.pause();\n    // abort all resource loads\n    for (var k in this.resources) {\n      var res = this.resources[k];\n      if (res._onLoadBinding) {\n        res._onLoadBinding.detach();\n      }\n      if (res.isLoading) {\n        res.abort('loader reset');\n      }\n    }\n    this.resources = {};\n    return this;\n  };\n  /**\n   * Starts loading the queued resources.\n   * @param cb - Optional callback that will be bound to the `complete` event.\n   * @return The loader itself.\n   */\n  Loader.prototype.load = function (cb) {\n    // register complete callback if they pass one\n    if (typeof cb === 'function') {\n      this.onComplete.once(cb);\n    }\n    // if the queue has already started we are done here\n    if (this.loading) {\n      return this;\n    }\n    if (this._queue.idle()) {\n      this._onStart();\n      this._onComplete();\n    } else {\n      // distribute progress chunks\n      var numTasks = this._queue._tasks.length;\n      var chunk = MAX_PROGRESS / numTasks;\n      for (var i = 0; i < this._queue._tasks.length; ++i) {\n        this._queue._tasks[i].data.progressChunk = chunk;\n      }\n      // notify we are starting\n      this._onStart();\n      // start loading\n      this._queue.resume();\n    }\n    return this;\n  };\n  Object.defineProperty(Loader.prototype, \"concurrency\", {\n    /**\n     * The number of resources to load concurrently.\n     *\n     * @default 10\n     */\n    get: function () {\n      return this._queue.concurrency;\n    },\n    set: function (concurrency) {\n      this._queue.concurrency = concurrency;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Prepares a url for usage based on the configuration of this object\n   * @param url - The url to prepare.\n   * @return The prepared url.\n   */\n  Loader.prototype._prepareUrl = function (url) {\n    var parsedUrl = parseUri(url, { strictMode: true });\n    var result;\n    // absolute url, just use it as is.\n    if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {\n      result = url;\n    }\n    // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n    else if (this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.charAt(0) !== '/') {\n        result = this.baseUrl + \"/\" + url;\n      } else {\n        result = this.baseUrl + url;\n      }\n    // if we need to add a default querystring, there is a bit more work\n    if (this.defaultQueryString) {\n      var hash = rgxExtractUrlHash.exec(result)[0];\n      result = result.slice(0, result.length - hash.length);\n      if (result.indexOf('?') !== -1) {\n        result += \"&\" + this.defaultQueryString;\n      } else {\n        result += \"?\" + this.defaultQueryString;\n      }\n      result += hash;\n    }\n    return result;\n  };\n  /**\n   * Loads a single resource.\n   *\n   * @param resource - The resource to load.\n   * @param dequeue - The function to call when we need to dequeue this item.\n   */\n  Loader.prototype._loadResource = function (resource, dequeue) {\n    var _this = this;\n    resource._dequeue = dequeue;\n    // run before middleware\n    AsyncQueue.eachSeries(this._beforeMiddleware, function (fn, next) {\n      fn.call(_this, resource, function () {\n        // if the before middleware marks the resource as complete,\n        // break and don't process any more before middleware\n        next(resource.isComplete ? {} : null);\n      });\n    }, function () {\n      if (resource.isComplete) {\n        _this._onLoad(resource);\n      } else {\n        resource._onLoadBinding = resource.onComplete.once(_this._onLoad, _this);\n        resource.load();\n      }\n    }, true);\n  };\n  /**\n   * Called once loading has started.\n   */\n  Loader.prototype._onStart = function () {\n    this.progress = 0;\n    this.loading = true;\n    this.onStart.dispatch(this);\n  };\n  /**\n   * Called once each resource has loaded.\n   */\n  Loader.prototype._onComplete = function () {\n    this.progress = MAX_PROGRESS;\n    this.loading = false;\n    this.onComplete.dispatch(this, this.resources);\n  };\n  /**\n   * Called each time a resources is loaded.\n   * @param resource - The resource that was loaded\n   */\n  Loader.prototype._onLoad = function (resource) {\n    var _this = this;\n    resource._onLoadBinding = null;\n    // remove this resource from the async queue, and add it to our list of resources that are being parsed\n    this._resourcesParsing.push(resource);\n    resource._dequeue();\n    // run all the after middleware for this resource\n    AsyncQueue.eachSeries(this._afterMiddleware, function (fn, next) {\n      fn.call(_this, resource, next);\n    }, function () {\n      resource.onAfterMiddleware.dispatch(resource);\n      _this.progress = Math.min(MAX_PROGRESS, _this.progress + resource.progressChunk);\n      _this.onProgress.dispatch(_this, resource);\n      if (resource.error) {\n        _this.onError.dispatch(resource.error, _this, resource);\n      } else {\n        _this.onLoad.dispatch(_this, resource);\n      }\n      _this._resourcesParsing.splice(_this._resourcesParsing.indexOf(resource), 1);\n      // do completion check\n      if (_this._queue.idle() && _this._resourcesParsing.length === 0) {\n        _this._onComplete();\n      }\n    }, true);\n  };\n  /**\n   * Destroy the loader, removes references.\n   */\n  Loader.prototype.destroy = function () {\n    if (!this._protected) {\n      this.reset();\n    }\n  };\n  Object.defineProperty(Loader, \"shared\", {\n    /**\n     * A premade instance of the loader that can be used to load resources.\n     */\n    get: function () {\n      var shared = Loader._shared;\n      if (!shared) {\n        shared = new Loader();\n        shared._protected = true;\n        Loader._shared = shared;\n      }\n      return shared;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Adds a Loader plugin for the global shared loader and all\n   * new Loader instances created.\n   *\n   * @param plugin - The plugin to add\n   * @return Reference to PIXI.Loader for chaining\n   */\n  Loader.registerPlugin = function (plugin) {\n    Loader._plugins.push(plugin);\n    if (plugin.add) {\n      plugin.add();\n    }\n    return Loader;\n  };\n  Loader._plugins = [];\n  return Loader;\n}();\nLoader.prototype.add = function add(name, url, options, callback) {\n  // special case of an array of objects or urls\n  if (Array.isArray(name)) {\n    for (var i = 0; i < name.length; ++i) {\n      this.add(name[i]);\n    }\n    return this;\n  }\n  // if an object is passed instead of params\n  if (typeof name === 'object') {\n    options = name;\n    callback = url || options.callback || options.onComplete;\n    url = options.url;\n    name = options.name || options.key || options.url;\n  }\n  // case where no name is passed shift all args over by one.\n  if (typeof url !== 'string') {\n    callback = options;\n    options = url;\n    url = name;\n  }\n  // now that we shifted make sure we have a proper url.\n  if (typeof url !== 'string') {\n    throw new Error('No url passed to add resource to loader.');\n  }\n  // options are optional so people might pass a function and no options\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  return this._add(name, url, options, callback);\n};\n\n/**\n * Application plugin for supporting loader option. Installing the LoaderPlugin\n * is not necessary if using **pixi.js** or **pixi.js-legacy**.\n * @example\n * import {AppLoaderPlugin} from '@pixi/loaders';\n * import {Application} from '@pixi/app';\n * Application.registerPlugin(AppLoaderPlugin);\n * @memberof PIXI\n */\nvar AppLoaderPlugin = /** @class */function () {\n  function AppLoaderPlugin() {}\n  /**\n   * Called on application constructor\n   *\n   * @private\n   */\n  AppLoaderPlugin.init = function (options) {\n    options = Object.assign({\n      sharedLoader: false\n    }, options);\n    this.loader = options.sharedLoader ? Loader.shared : new Loader();\n  };\n  /**\n   * Called when application destroyed\n   *\n   * @private\n   */\n  AppLoaderPlugin.destroy = function () {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  };\n  return AppLoaderPlugin;\n}();\n\n/**\n * Loader plugin for handling Texture resources.\n *\n * @memberof PIXI\n */\nvar TextureLoader = /** @class */function () {\n  function TextureLoader() {}\n  /**\n   * Handle SVG elements a text, render with SVGResource.\n   */\n  TextureLoader.add = function () {\n    LoaderResource.setExtensionLoadType('svg', LoaderResource.LOAD_TYPE.XHR);\n    LoaderResource.setExtensionXhrType('svg', LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n  };\n  /**\n   * Called after a resource is loaded.\n   * @see PIXI.Loader.loaderMiddleware\n   * @param resource\n   * @param {function} next\n   */\n  TextureLoader.use = function (resource, next) {\n    // create a new texture if the data is an Image object\n    if (resource.data && (resource.type === LoaderResource.TYPE.IMAGE || resource.extension === 'svg')) {\n      var data = resource.data,\n          url = resource.url,\n          name = resource.name,\n          metadata = resource.metadata;\n      _core.Texture.fromLoader(data, url, name, metadata).then(function (texture) {\n        resource.texture = texture;\n        next();\n      })\n      // TODO: handle errors in Texture.fromLoader\n      // so we can pass them to the Loader\n      .catch(next);\n    } else {\n      next();\n    }\n  };\n  return TextureLoader;\n}();\n\nvar _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n/**\n * Encodes binary into base64.\n *\n * @function encodeBinary\n * @param {string} input - The input data to encode.\n * @returns {string} The encoded base64 string\n */\nfunction encodeBinary(input) {\n  var output = '';\n  var inx = 0;\n  while (inx < input.length) {\n    // Fill byte buffer array\n    var bytebuffer = [0, 0, 0];\n    var encodedCharIndexes = [0, 0, 0, 0];\n    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {\n      if (inx < input.length) {\n        // throw away high-order byte, as documented at:\n        // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n        bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n      } else {\n        bytebuffer[jnx] = 0;\n      }\n    }\n    // Get each encoded character, 6 bits at a time\n    // index 1: first 6 bits\n    encodedCharIndexes[0] = bytebuffer[0] >> 2;\n    // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n    encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4;\n    // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n    encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6;\n    // index 3: forth 6 bits (6 least significant bits from input byte 3)\n    encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n    // Determine whether padding happened, and adjust accordingly\n    var paddingBytes = inx - (input.length - 1);\n    switch (paddingBytes) {\n      case 2:\n        // Set last 2 characters to padding char\n        encodedCharIndexes[3] = 64;\n        encodedCharIndexes[2] = 64;\n        break;\n      case 1:\n        // Set last character to padding char\n        encodedCharIndexes[3] = 64;\n        break;\n    }\n    // Now we will grab each appropriate character out of our keystring\n    // based on our index array and append it to the output string\n    for (var jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {\n      output += _keyStr.charAt(encodedCharIndexes[jnx]);\n    }\n  }\n  return output;\n}\n\n/**\n * A middleware for transforming XHR loaded Blobs into more useful objects\n *\n * @ignore\n * @function parsing\n * @example\n * import { Loader, middleware } from 'resource-loader';\n * const loader = new Loader();\n * loader.use(middleware.parsing);\n * @param resource - Current Resource\n * @param next - Callback when complete\n */\nfunction parsing(resource, next) {\n  if (!resource.data) {\n    next();\n    return;\n  }\n  // if this was an XHR load of a blob\n  if (resource.xhr && resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {\n    // if there is no blob support we probably got a binary string back\n    if (!self.Blob || typeof resource.data === 'string') {\n      var type = resource.xhr.getResponseHeader('content-type');\n      // this is an image, convert the binary string into a data url\n      if (type && type.indexOf('image') === 0) {\n        resource.data = new Image();\n        resource.data.src = \"data:\" + type + \";base64,\" + encodeBinary(resource.xhr.responseText);\n        resource.type = LoaderResource.TYPE.IMAGE;\n        // wait until the image loads and then callback\n        resource.data.onload = function () {\n          resource.data.onload = null;\n          next();\n        };\n        // next will be called on load\n        return;\n      }\n    }\n    // if content type says this is an image, then we should transform the blob into an Image object\n    else if (resource.data.type.indexOf('image') === 0) {\n        var Url_1 = globalThis.URL || globalThis.webkitURL;\n        var src_1 = Url_1.createObjectURL(resource.data);\n        resource.blob = resource.data;\n        resource.data = new Image();\n        resource.data.src = src_1;\n        resource.type = LoaderResource.TYPE.IMAGE;\n        // cleanup the no longer used blob after the image loads\n        // TODO: Is this correct? Will the image be invalid after revoking?\n        resource.data.onload = function () {\n          Url_1.revokeObjectURL(src_1);\n          resource.data.onload = null;\n          next();\n        };\n        // next will be called on load.\n        return;\n      }\n  }\n  next();\n}\n\n// parse any blob into more usable objects (e.g. Image)\nLoader.registerPlugin({ use: parsing });\n// parse any Image objects into textures\nLoader.registerPlugin(TextureLoader);\n\nexports.AppLoaderPlugin = AppLoaderPlugin;\nexports.Loader = Loader;\nexports.LoaderResource = LoaderResource;\nexports.TextureLoader = TextureLoader;\n//# sourceMappingURL=loaders.js.map"},"hash":"ecc0872bdca5973b0cbedebf3fe3cb6e"}