{"dependencies":[{"name":"@pixi/math","loc":{"line":8,"column":26}},{"name":"@pixi/core","loc":{"line":9,"column":37}},{"name":"@pixi/utils","loc":{"line":10,"column":40}},{"name":"@pixi/loaders","loc":{"line":11,"column":31}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SpritesheetLoader = exports.Spritesheet = undefined;\n\nvar _math = require(\"@pixi/math\");\n\nvar _core = require(\"@pixi/core\");\n\nvar _utils = require(\"@pixi/utils\");\n\nvar _loaders = require(\"@pixi/loaders\");\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @memberof PIXI\n */\n/*!\n * @pixi/spritesheet - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Spritesheet = /** @class */function () {\n  /**\n   * @param baseTexture - Reference to the source BaseTexture object.\n   * @param {Object} data - Spritesheet image data.\n   * @param resolutionFilename - The filename to consider when determining\n   *        the resolution of the spritesheet. If not provided, the imageUrl will\n   *        be used on the BaseTexture.\n   */\n  function Spritesheet(texture, data, resolutionFilename) {\n    if (resolutionFilename === void 0) {\n      resolutionFilename = null;\n    }\n    this._texture = texture instanceof _core.Texture ? texture : null;\n    this.baseTexture = texture instanceof _core.BaseTexture ? texture : this._texture.baseTexture;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    var resource = this.baseTexture.resource;\n    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Generate the resolution from the filename or fallback\n   * to the meta.scale field of the JSON data.\n   *\n   * @param resolutionFilename - The filename to use for resolving\n   *        the default resolution.\n   * @return Resolution to use for spritesheet.\n   */\n  Spritesheet.prototype._updateResolution = function (resolutionFilename) {\n    if (resolutionFilename === void 0) {\n      resolutionFilename = null;\n    }\n    var scale = this.data.meta.scale;\n    // Use a defaultValue of `null` to check if a url-based resolution is set\n    var resolution = (0, _utils.getResolutionOfUrl)(resolutionFilename, null);\n    // No resolution found via URL\n    if (resolution === null) {\n      // Use the scale value or default to 1\n      resolution = scale !== undefined ? parseFloat(scale) : 1;\n    }\n    // For non-1 resolutions, update baseTexture\n    if (resolution !== 1) {\n      this.baseTexture.setResolution(resolution);\n    }\n    return resolution;\n  };\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   *\n   * @param {Function} callback - Callback when complete returns\n   *        a map of the Textures for this spritesheet.\n   */\n  Spritesheet.prototype.parse = function (callback) {\n    this._batchIndex = 0;\n    this._callback = callback;\n    if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {\n      this._processFrames(0);\n      this._processAnimations();\n      this._parseComplete();\n    } else {\n      this._nextBatch();\n    }\n  };\n  /**\n   * Process a batch of frames\n   *\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  Spritesheet.prototype._processFrames = function (initialFrameIndex) {\n    var frameIndex = initialFrameIndex;\n    var maxFrames = Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      var i = this._frameKeys[frameIndex];\n      var data = this._frames[i];\n      var rect = data.frame;\n      if (rect) {\n        var frame = null;\n        var trim = null;\n        var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        var orig = new _math.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n        if (data.rotated) {\n          frame = new _math.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n        } else {\n          frame = new _math.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        //  Check to see if the sprite is trimmed\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new _math.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        this.textures[i] = new _core.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);\n        // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n        _core.Texture.addToCache(this.textures[i], i);\n      }\n      frameIndex++;\n    }\n  };\n  /** Parse animations config. */\n  Spritesheet.prototype._processAnimations = function () {\n    var animations = this.data.animations || {};\n    for (var animName in animations) {\n      this.animations[animName] = [];\n      for (var i = 0; i < animations[animName].length; i++) {\n        var frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  };\n  /** The parse has completed. */\n  Spritesheet.prototype._parseComplete = function () {\n    var callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  };\n  /** Begin the next batch of textures. */\n  Spritesheet.prototype._nextBatch = function () {\n    var _this = this;\n    this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(function () {\n      if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) {\n        _this._nextBatch();\n      } else {\n        _this._processAnimations();\n        _this._parseComplete();\n      }\n    }, 0);\n  };\n  /**\n   * Destroy Spritesheet and don't use after this.\n   *\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  Spritesheet.prototype.destroy = function (destroyBase) {\n    var _a;\n    if (destroyBase === void 0) {\n      destroyBase = false;\n    }\n    for (var i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.destroy();\n      this.baseTexture.destroy();\n    }\n    this._texture = null;\n    this.baseTexture = null;\n  };\n  /** The maximum number of Textures to build per process. */\n  Spritesheet.BATCH_SIZE = 1000;\n  return Spritesheet;\n}();\n/**\n * Reference to Spritesheet object created.\n * @member {PIXI.Spritesheet} spritesheet\n * @memberof PIXI.LoaderResource\n * @instance\n */\n/**\n * Dictionary of textures from Spritesheet.\n * @member {object<string, PIXI.Texture>} textures\n * @memberof PIXI.LoaderResource\n * @instance\n */\n\n/**\n * {@link PIXI.Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * If you're using Webpack or other bundlers and plan on bundling the atlas' JSON,\n * use the {@link PIXI.Spritesheet} class to directly parse the JSON.\n *\n * The Loader's image Resource name is automatically appended with `\"_image\"`.\n * If a Resource with this name is already loaded, the Loader will skip parsing the\n * Spritesheet. The code below will generate an internal Loader Resource called `\"myatlas_image\"`.\n *\n * @example\n * loader.add('myatlas', 'path/to/myatlas.json');\n * loader.load(() => {\n *   loader.resources.myatlas; // atlas JSON resource\n *   loader.resources.myatlas_image; // atlas Image resource\n * });\n *\n * @memberof PIXI\n */\nvar SpritesheetLoader = /** @class */function () {\n  function SpritesheetLoader() {}\n  /**\n   * Called after a resource is loaded.\n   *\n   * @see PIXI.Loader.loaderMiddleware\n   * @param resource\n   * @param next\n   */\n  SpritesheetLoader.use = function (resource, next) {\n    var _a, _b;\n    // because this is middleware, it execute in loader context. `this` = loader\n    var loader = this;\n    var imageResourceName = resource.name + \"_image\";\n    // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n    if (!resource.data || resource.type !== _loaders.LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {\n      next();\n      return;\n    }\n    // Check and add the multi atlas\n    // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n    // eslint-disable-next-line camelcase\n    var multiPacks = (_b = (_a = resource.data) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.related_multi_packs;\n    if (Array.isArray(multiPacks)) {\n      var _loop_1 = function (item) {\n        if (typeof item !== 'string') {\n          return \"continue\";\n        }\n        var itemName = item.replace('.json', '');\n        var itemUrl = _utils.url.resolve(resource.url.replace(loader.baseUrl, ''), item);\n        // Check if the file wasn't already added as multipacks are redundant\n        if (loader.resources[itemName] || Object.values(loader.resources).some(function (r) {\n          return _utils.url.format(_utils.url.parse(r.url)) === itemUrl;\n        })) {\n          return \"continue\";\n        }\n        var options = {\n          crossOrigin: resource.crossOrigin,\n          loadType: _loaders.LoaderResource.LOAD_TYPE.XHR,\n          xhrType: _loaders.LoaderResource.XHR_RESPONSE_TYPE.JSON,\n          parentResource: resource,\n          metadata: resource.metadata\n        };\n        loader.add(itemName, itemUrl, options);\n      };\n      for (var _i = 0, multiPacks_1 = multiPacks; _i < multiPacks_1.length; _i++) {\n        var item = multiPacks_1[_i];\n        _loop_1(item);\n      }\n    }\n    var loadOptions = {\n      crossOrigin: resource.crossOrigin,\n      metadata: resource.metadata.imageMetadata,\n      parentResource: resource\n    };\n    var resourcePath = SpritesheetLoader.getResourcePath(resource, loader.baseUrl);\n    // load the image for this sheet\n    loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {\n      if (res.error) {\n        next(res.error);\n        return;\n      }\n      var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);\n      spritesheet.parse(function () {\n        resource.spritesheet = spritesheet;\n        resource.textures = spritesheet.textures;\n        next();\n      });\n    });\n  };\n  /**\n   * Get the spritesheets root path\n   *\n   * @param resource - Resource to check path\n   * @param baseUrl - Base root url\n   */\n  SpritesheetLoader.getResourcePath = function (resource, baseUrl) {\n    // Prepend url path unless the resource image is a data url\n    if (resource.isDataUrl) {\n      return resource.data.meta.image;\n    }\n    return _utils.url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);\n  };\n  return SpritesheetLoader;\n}();\n\nexports.Spritesheet = Spritesheet;\nexports.SpritesheetLoader = SpritesheetLoader;\n//# sourceMappingURL=spritesheet.js.map"},"hash":"de09591b1f3aebc94021e10f7849feac"}