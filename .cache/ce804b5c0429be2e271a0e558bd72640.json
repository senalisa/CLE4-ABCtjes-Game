{"dependencies":[{"name":"@pixi/core","loc":{"line":8,"column":24}},{"name":"@pixi/sprite","loc":{"line":9,"column":23}},{"name":"@pixi/ticker","loc":{"line":10,"column":40}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnimatedSprite = undefined;\n\nvar _core = require(\"@pixi/core\");\n\nvar _sprite = require(\"@pixi/sprite\");\n\nvar _ticker = require(\"@pixi/ticker\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return extendStatics(d, b);\n}; /*!\n    * @pixi/sprite-animated - v6.3.2\n    * Compiled Wed, 04 May 2022 17:49:13 UTC\n    *\n    * @pixi/sprite-animated is licensed under the MIT License.\n    * http://www.opensource.org/licenses/mit-license\n    */\n\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n *\n * ```js\n * let alienImages = [\"image_sequence_01.png\",\"image_sequence_02.png\",\"image_sequence_03.png\",\"image_sequence_04.png\"];\n * let textureArray = [];\n *\n * for (let i=0; i < 4; i++)\n * {\n *      let texture = PIXI.Texture.from(alienImages[i]);\n *      textureArray.push(texture);\n * };\n *\n * let animatedSprite = new PIXI.AnimatedSprite(textureArray);\n * ```\n *\n * The more efficient and simpler way to create an animated sprite is using a {@link PIXI.Spritesheet}\n * containing the animation definitions:\n *\n * ```js\n * PIXI.Loader.shared.add(\"assets/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"assets/spritesheet.json\"].spritesheet;\n *   animatedSprite = new PIXI.AnimatedSprite(sheet.animations[\"image_sequence\"]);\n *   ...\n * }\n * ```\n *\n * @memberof PIXI\n */\nvar AnimatedSprite = /** @class */function (_super) {\n  __extends(AnimatedSprite, _super);\n  /**\n   * @param textures - An array of {@link PIXI.Texture} or frame\n   *  objects that make up the animation.\n   * @param {boolean} [autoUpdate=true] - Whether to use PIXI.Ticker.shared to auto update animation time.\n   */\n  function AnimatedSprite(textures, autoUpdate) {\n    if (autoUpdate === void 0) {\n      autoUpdate = true;\n    }\n    var _this = _super.call(this, textures[0] instanceof _core.Texture ? textures[0] : textures[0].texture) || this;\n    _this._textures = null;\n    _this._durations = null;\n    _this._autoUpdate = autoUpdate;\n    _this._isConnectedToTicker = false;\n    _this.animationSpeed = 1;\n    _this.loop = true;\n    _this.updateAnchor = false;\n    _this.onComplete = null;\n    _this.onFrameChange = null;\n    _this.onLoop = null;\n    _this._currentTime = 0;\n    _this._playing = false;\n    _this._previousFrame = null;\n    _this.textures = textures;\n    return _this;\n  }\n  /** Stops the AnimatedSprite. */\n  AnimatedSprite.prototype.stop = function () {\n    if (!this._playing) {\n      return;\n    }\n    this._playing = false;\n    if (this._autoUpdate && this._isConnectedToTicker) {\n      _ticker.Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  };\n  /** Plays the AnimatedSprite. */\n  AnimatedSprite.prototype.play = function () {\n    if (this._playing) {\n      return;\n    }\n    this._playing = true;\n    if (this._autoUpdate && !this._isConnectedToTicker) {\n      _ticker.Ticker.shared.add(this.update, this, _ticker.UPDATE_PRIORITY.HIGH);\n      this._isConnectedToTicker = true;\n    }\n  };\n  /**\n   * Stops the AnimatedSprite and goes to a specific frame.\n   *\n   * @param frameNumber - Frame index to stop at.\n   */\n  AnimatedSprite.prototype.gotoAndStop = function (frameNumber) {\n    this.stop();\n    var previousFrame = this.currentFrame;\n    this._currentTime = frameNumber;\n    if (previousFrame !== this.currentFrame) {\n      this.updateTexture();\n    }\n  };\n  /**\n   * Goes to a specific frame and begins playing the AnimatedSprite.\n   *\n   * @param frameNumber - Frame index to start at.\n   */\n  AnimatedSprite.prototype.gotoAndPlay = function (frameNumber) {\n    var previousFrame = this.currentFrame;\n    this._currentTime = frameNumber;\n    if (previousFrame !== this.currentFrame) {\n      this.updateTexture();\n    }\n    this.play();\n  };\n  /**\n   * Updates the object transform for rendering.\n   *\n   * @param deltaTime - Time since last tick.\n   */\n  AnimatedSprite.prototype.update = function (deltaTime) {\n    if (!this._playing) {\n      return;\n    }\n    var elapsed = this.animationSpeed * deltaTime;\n    var previousFrame = this.currentFrame;\n    if (this._durations !== null) {\n      var lag = this._currentTime % 1 * this._durations[this.currentFrame];\n      lag += elapsed / 60 * 1000;\n      while (lag < 0) {\n        this._currentTime--;\n        lag += this._durations[this.currentFrame];\n      }\n      var sign = Math.sign(this.animationSpeed * deltaTime);\n      this._currentTime = Math.floor(this._currentTime);\n      while (lag >= this._durations[this.currentFrame]) {\n        lag -= this._durations[this.currentFrame] * sign;\n        this._currentTime += sign;\n      }\n      this._currentTime += lag / this._durations[this.currentFrame];\n    } else {\n      this._currentTime += elapsed;\n    }\n    if (this._currentTime < 0 && !this.loop) {\n      this.gotoAndStop(0);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (this._currentTime >= this._textures.length && !this.loop) {\n      this.gotoAndStop(this._textures.length - 1);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (previousFrame !== this.currentFrame) {\n      if (this.loop && this.onLoop) {\n        if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {\n          this.onLoop();\n        } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n          this.onLoop();\n        }\n      }\n      this.updateTexture();\n    }\n  };\n  /** Updates the displayed texture to match the current frame index. */\n  AnimatedSprite.prototype.updateTexture = function () {\n    var currentFrame = this.currentFrame;\n    if (this._previousFrame === currentFrame) {\n      return;\n    }\n    this._previousFrame = currentFrame;\n    this._texture = this._textures[currentFrame];\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    this._cachedTint = 0xFFFFFF;\n    this.uvs = this._texture._uvs.uvsFloat32;\n    if (this.updateAnchor) {\n      this._anchor.copyFrom(this._texture.defaultAnchor);\n    }\n    if (this.onFrameChange) {\n      this.onFrameChange(this.currentFrame);\n    }\n  };\n  /**\n   * Stops the AnimatedSprite and destroys it.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy\n   *      method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.\n   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.\n   */\n  AnimatedSprite.prototype.destroy = function (options) {\n    this.stop();\n    _super.prototype.destroy.call(this, options);\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n  };\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of frame ids.\n   *\n   * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n   * @return - The new animated sprite with the specified frames.\n   */\n  AnimatedSprite.fromFrames = function (frames) {\n    var textures = [];\n    for (var i = 0; i < frames.length; ++i) {\n      textures.push(_core.Texture.from(frames[i]));\n    }\n    return new AnimatedSprite(textures);\n  };\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of image ids.\n   *\n   * @param images - The array of image urls the AnimatedSprite will use as its texture frames.\n   * @return The new animate sprite with the specified images as frames.\n   */\n  AnimatedSprite.fromImages = function (images) {\n    var textures = [];\n    for (var i = 0; i < images.length; ++i) {\n      textures.push(_core.Texture.from(images[i]));\n    }\n    return new AnimatedSprite(textures);\n  };\n  Object.defineProperty(AnimatedSprite.prototype, \"totalFrames\", {\n    /**\n     * The total number of frames in the AnimatedSprite. This is the same as number of textures\n     * assigned to the AnimatedSprite.\n     *\n     * @readonly\n     * @default 0\n     */\n    get: function () {\n      return this._textures.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimatedSprite.prototype, \"textures\", {\n    /** The array of textures used for this AnimatedSprite. */\n    get: function () {\n      return this._textures;\n    },\n    set: function (value) {\n      if (value[0] instanceof _core.Texture) {\n        this._textures = value;\n        this._durations = null;\n      } else {\n        this._textures = [];\n        this._durations = [];\n        for (var i = 0; i < value.length; i++) {\n          this._textures.push(value[i].texture);\n          this._durations.push(value[i].time);\n        }\n      }\n      this._previousFrame = null;\n      this.gotoAndStop(0);\n      this.updateTexture();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimatedSprite.prototype, \"currentFrame\", {\n    /**\n     * The AnimatedSprites current frame index.\n     *\n     * @readonly\n     */\n    get: function () {\n      var currentFrame = Math.floor(this._currentTime) % this._textures.length;\n      if (currentFrame < 0) {\n        currentFrame += this._textures.length;\n      }\n      return currentFrame;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimatedSprite.prototype, \"playing\", {\n    /**\n     * Indicates if the AnimatedSprite is currently playing.\n     *\n     * @readonly\n     */\n    get: function () {\n      return this._playing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimatedSprite.prototype, \"autoUpdate\", {\n    /** Whether to use PIXI.Ticker.shared to auto update animation time. */\n    get: function () {\n      return this._autoUpdate;\n    },\n    set: function (value) {\n      if (value !== this._autoUpdate) {\n        this._autoUpdate = value;\n        if (!this._autoUpdate && this._isConnectedToTicker) {\n          _ticker.Ticker.shared.remove(this.update, this);\n          this._isConnectedToTicker = false;\n        } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n          _ticker.Ticker.shared.add(this.update, this);\n          this._isConnectedToTicker = true;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return AnimatedSprite;\n}(_sprite.Sprite);\n\nexports.AnimatedSprite = AnimatedSprite;\n//# sourceMappingURL=sprite-animated.js.map"},"hash":"a418526dc87f98b58d37a7c8f9887c97"}